<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>决策树和随机森林是个啥呢？</title>
      <link href="2021/03/28/guan-yu-jue-ce-shu-yu-sui-ji-sen-lin-de-qian-xian-ren-shi/"/>
      <url>2021/03/28/guan-yu-jue-ce-shu-yu-sui-ji-sen-lin-de-qian-xian-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="关于决策树与随机森林的浅显认识"><a href="#关于决策树与随机森林的浅显认识" class="headerlink" title="关于决策树与随机森林的浅显认识"></a>关于决策树与随机森林的浅显认识</h1><h2 id="决策树是啥？"><a href="#决策树是啥？" class="headerlink" title="决策树是啥？"></a>决策树是啥？</h2><ul><li>百度百科上对于决策树的一些解释</li></ul><p>决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。</p><p>决策树(Decision Tree）是在已知各种情况发生概率的<a href="https://baike.baidu.com/item/%E5%9F%BA%E7%A1%80/32794">基础</a>上，通过构成决策树来求取净现值的<a href="https://baike.baidu.com/item/%E6%9C%9F%E6%9C%9B/35704">期望</a>值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。在机器学习中，决策树是一个预测模型，他代表的是对象属性与对象值之间的一种映射关系。Entropy = 系统的凌乱程度，使用算法<a href="https://baike.baidu.com/item/ID3">ID3</a>, <a href="https://baike.baidu.com/item/C4.5">C4.5</a>和C5.0生成树算法使用熵。</p><ul><li>接下来是我自己通过查阅相关资料和书籍后对于决策树的一些了解</li></ul><p>首先我了解决策树的来源是西瓜书，书上对于决策树用于分类做出了一定的阐述。过于专业的术语就不罗列了，我用通俗的语言把自己的浅显理解表示出来，决策树是通过树形结构，在树的节点上根据数据的某些特来将根节点上输入的数据进行逐次的分类，最终到达叶子节点的时候就能够对根节点上输入的数据进行做出分类。可能说起来表述不是特别直观，我们可以通过书上的例子来理解。</p><p><img src="https://wx3.sinaimg.cn/mw690/006pSJjJly1gozzv1z2ofj30i40bkkjl.jpg" alt="对西瓜是否是好瓜的分类"></p><p>可以从图上看出每个节点的分叉不一定就是两个，可以根据该特征的表现而分出多个叉。</p><ul><li>决策树是如何生产的呢？</li></ul><p>之前图上的决策树可以很直观的看出来一个西瓜从输入到决策树之后是如何的一步一步的按照西瓜自身的特征被分成好瓜和坏瓜。这也决策树和其他机器学习方法（比如深度学习）所更具有优势的地方，那就是决策树的可解释性很强，每一步是怎么来的都可以清晰明了的知道，而不像深度网络的训练那样是个黑盒模型，深度网络本身就不可解释，再加上深度网络的层数加深的时候，这个黑盒也就黑上加黑了。</p><p>那么像图上的那个决策树是怎么知道用哪些西瓜的特征呢？ 那些特征又是如何排序的呢？ 特征所占权重又是如何的呢？ </p><p>上面所有的问题其实都是由决策树的一些算法（如ID3,C4.5）来自己决定的，只要给够数据集，这些都就不用考虑。但是我们学习肯定要抱着求知的心态。所以我也就对其中的一种算法ID3算法做一个简单的介绍。</p><ul><li>ID3</li></ul><p>首先我们要了解一个这个算法涉及的一个知识，那就是信息熵。我对于熵的理解十分浅显，仅限于知道它描述一个系统的混乱程度，一个系统越混乱，那么他的熵就越大，而所有的系统从一开始随着时间的推进，系统的熵是会越来越大的，也就是系统会逐渐的进入到混乱的状态。</p><p>对于熵我还是引用一些dalao的说法：{</p><p>基本思想<strong>是以信息熵</strong>为度量构造一棵熵值下降最快的树，到叶子节点处的熵值为零，此时每个叶节点中的实例都属于同一类。</p><p>ID3算法的核心思想就是以信息增益度量属性选择，选择分裂后信息增益最大（我理解为信息熵-不确定性减小最快）的属性进行分裂。</p><p><em>什么是信息增益？</em></p><p>信息增益表示得知特征A的信息而使得类X的信息的不确定性减少的程度。</p><p>设D为用类别对训练元组进行的划分，则D的<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Entropy">熵</a>（entropy）表示为：</p><p>其中pi表示第i个类别在整个训练元组中出现的概率，可以用属于此类别元素的数量除以训练元组元素总数量作为估计。</p><p>}</p><p>结合之前的图来理解：</p><p>而对于一棵决策树来说呢，从一开始训练一棵树的时候，会把所有的数据集都丢在根节点，此时根节点中的所有数据都是未分类的，那么可以说这个时候根节点的熵是最大的（因为完全未分类，全混乱的自然是熵最大的），但是在训练的过程中，每个节点都代表了一个特征，经过一个节点的分类之后，在下一层中的每个节点中的数据都是经过上一个节点分类下来的，所以说每个节点中的熵都是相较于上一次更小的，那么这一层的所有节点的熵加在一起的和自然也就小于上一层中所有节点的熵之和，这就是ID3算法的思想了，<strong>每一次的熵之和都递减</strong>。依照这个中心思想来训练一棵树，就会按照数据本身的特性来生成树。</p><ul><li><p>那么决策树如何评价决策树这种分类方式呢？</p></li><li><p>优势：</p></li></ul><p>1、便于理解和解释。树的结构可视化<br>2、训练需要的数据少，其他机器学习模型通常需要数据规范化，比如构建虚拟变量和移除缺失值<br>3、由于训练决策树的数据点的数量导致了决策树的使用开销呈指数分布（训练树模型的时间复杂度是参加训练数据点的对数值）<br>4、能够处理数值型数据和分类数据，其他的技术通常只能用来专门分析某一种的变量类型的数据集；<br>5、能够处理多路输出问题；<br>6、使用白盒模型。如果某种给定的情况在模型中是可以观察的，那么就可以轻易的通过布尔逻辑来解释这种情况，相比之下在黑盒模型中的结果就是很难说明清楚了；<br>7、可以通过数值统计测试来验证该模型。这对解释验证该模型的可靠性成为可能；<br>8、即使是该模型假设的结果越真实模型所提供的数据有些违反，其表现依旧良好；</p><ul><li>缺点总而言之就是——容易过拟合</li></ul><p>1、决策树模型容易产生一个过于复杂的模型，这样的模型对数据的泛化性能会很差。这就是所谓的过拟合，一些策略像剪枝、设置叶节点所需要的最小样本数或者设置数的最大深度就是避免出现该问题的最有效的方法。（剪枝：在机器学习经典算法中，决策树算法的重要性想必大家都是知道的。不管是ID3算法还是比如C4.5算法等等，都面临一个问题，就是通过直接生成的完全决策树对于训练样本来说是“过度拟合”的，说白了是太精确了。由于完全决策树对训练样本的特征描述得“过于精确” ,无法实现对新样本的合理分析, 所以此时它不是一棵分析新数据的最佳决策树。解决这个问题的方法就是对决策树进行剪枝，剪去影响预测精度的分支。常见的剪枝策略有预剪枝(pre -pruning)技术和后剪枝(post -pruning )技术两种。预剪枝技术主要是通过建立某些规则限制决策树的充分生长, 后剪枝技术则是待决策树充分生长完毕后再进行剪枝。）<br>2、决策树可能是不稳定的，因为在数据中的微小变化可能会导致完全不同的树生成。这个问题可以通过决策树的集成来得到缓解；<br>3、在多方面性能最优和简单化概念的要求下，学习一颗最优决策树通常是一个NP难问题；<br>因此，实际的决策树学习算法是基于启发式算法，例如在每个节点进行局部最优决策的贪心算法，这样的算法不能保证返回全局最有决策树，这个问题可以通过集成学习来训练多颗决策树来缓解，这多棵决策树一般通过对特征和样本又放回的随机采样来生成；<br>4、有些概念很难被决策树学习到，因为决策树很难清楚的表述那些概念，例如XOR，奇偶或者复用器问题；<br>5、如果某些类在问题中占主导地位会使得创始的决策树有偏差，因此建议在拟合前先对数据集进行平衡。</p><h2 id="随机森林呢？"><a href="#随机森林呢？" class="headerlink" title="随机森林呢？"></a>随机森林呢？</h2><ul><li>之前说了决策树的各种好处，但是他就是不好在容易过拟合。</li></ul><p>那么如何解决过拟合的问题呢？难道因为容易过拟合我们就要放弃这个好的分类器了吗？ 答案自然是不，既然有问题那我们就去解决，然后就出现了更加神奇的随机森林。</p><p>听名字就可以看出来，一个树是决策树，那么有很多随机的树的时候，那就是随机森林了，说起来十分的简单，其实还是有很多不一样的地方。</p><p>森林有了，那么森林中的树是如何生产的呢？还是随机森林。</p><p>生成规则如下：</p><ul><li>如果训练集大小为N，对于每棵树而言，随机且有放回地从训练集中的抽取N个训练样本（这种采样方式称为bootstrap sample方法)，作为该树的训练集; 从这里我们就可以知道，每棵树训练集都是不同的，而且里面包含重复的训练样本（十分重要）。</li><li>那么为什么要随机抽样训练集呢？</li></ul><p>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的，重复的决策树那么该过拟合还是会过拟合。</p><ul><li>那么为什么要有放回地抽样呢?</li></ul><p>我理解的是这样的:如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是”有偏的””，都是绝对”片面的”(当然这样说可能不对)，也就是说每棵树训练出来都是有很大的差异的;而随机森林最后分类取决于多棵树(弱分类器)的投票表决，这种表决应该是”求同””，因此使用完全不同的训练集来训练每棵树这样对最终分类结果是没有帮助的，这样无异于是盲人摸象”。</p><ul><li>如果每个样本的特征维度为M，指定一个常数m&lt;&lt;M，随机地从M个特征中选取m个特征子集，每次树进行分裂时，从这m个特征中选择最优的;</li></ul><ul><li>每棵树都尽最大程度的生长，并且没有剪枝过程。<br>一开始我们提到的随机森林中的”随机”就是指的这里的两个随机性。两个随机性的引入对随机森林的分类性能至关重要。由于它们的引入，使得随机森林不容易陷入过拟合，并且具有很好得抗噪能力(比如:对缺省值不敏感)。</li></ul><ul><li><p>随机森林的分类效果和什么因素有关呢？</p><p>1，森林中任意两棵树的相关性:相关性越大，错误率越大;</p><p>2，森林中每棵树的分类能力:每棵树的分类能力越强，整个森林的错误率越低。</p><p><img src="https://wx1.sinaimg.cn/mw690/006pSJjJly1gozzw34trwj30m30doq8j.jpg" alt="这就是一个由三个决策树构成的小森林"></p></li></ul><p>————————————————————————————</p><ul><li>我能够用我自己最通俗的语言来描述随机森林：</li></ul><p>随机森林就像是民主选举，森林就是一个国家，每个决策树都是一个公民，因为每个人的所见所闻都不一样（指训练时候是随机抽样训练的），那么每个公民都对选举（输入的数据或者图片）都有着自己个人的见解（不同数据训练出来的决策树结构都不同，对特征的敏感性也不同），最后每个公民都会对选举做出自己的选择，最后再统计所有公民的选择作为最后的决定。</p><p>正式因为每棵树都有种不同，并且是由不同的很多树共同来做出结果，所以过拟合的问题就这样迎刃而解了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机森林 </tag>
            
            <tag> 决策树 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人脸识别入门内容简介</title>
      <link href="2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/"/>
      <url>2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="（个人向）人脸识别，图像处理内容入门学习。"><a href="#（个人向）人脸识别，图像处理内容入门学习。" class="headerlink" title="（个人向）人脸识别，图像处理内容入门学习。"></a>（个人向）人脸识别，图像处理内容入门学习。</h1><h2 id="背景及意义"><a href="#背景及意义" class="headerlink" title="背景及意义"></a>背景及意义</h2><p>人脸识别，是基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，利用人脸固有的特征信息进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。是模式识别和人工智能最广泛的应用之一，通常也叫做人像识别、面部识别。</p><h2 id="人脸识别过程简述"><a href="#人脸识别过程简述" class="headerlink" title="人脸识别过程简述"></a>人脸识别过程简述</h2><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goykslj28yj30if0jcdj4.jpg" alt="人脸识别流程图"></p><ol><li>人脸图像采集及检测</li></ol><p>人脸图像采集,不同的人脸图像都能通过图像采集设备采集下来，比如静态的图像、动态图像、不同的位置、不同表情等方面都可以得到很好的采集。人脸检测，在实际中主要用于人脸识别的预处理，即就是在图像中准确标出人脸的位置和大小，人脸图像中包含的模式特征十分丰富，如直方图特征、颜色特征、模板特征、结构特征等。人脸检测就是把这其中有用的信息挑出来，并利用这些特征实现人脸检测。</p><ol start="2"><li>人脸图像预处理</li></ol><p>这是以人脸检测结果为基础的，对图像进行处理并最终服务于特征提取的过程。系统获取的原始图像由于受到各种条件的限制和随机干扰，往往不能直接使用，必须在图像处理的早期阶段对它进行灰度校正、噪声过滤等图像预处理。对于人脸图像而言，其预处理过程主要包括人脸图像的光线补偿、灰度变换、直方图均衡化、归一化、几何校正、滤波以及锐化等。</p><ol start="3"><li>人脸图像特征提取</li></ol><p>人脸图像特征提取：人脸识别系统可使用的特征通常分为视觉特征、像素统计特征、人脸图像变换系数特征、人脸图像代数特征等。人脸特征提取就是针对人脸的某些特征进行的。人脸特征提取，也称人脸表征，它是对人脸进行特征建模的过程。人脸特征提取的方法归纳起来分为两大类：一种是基于知识的表征方法；另外一种是基于代数特征或统计学习的表征方法。</p><ol start="4"><li>人脸图像匹配与识别</li></ol><p>人脸图像匹配与识别：提取的人脸图像的特征数据与数据库中存储的特征模板进行搜索匹配，通过设定一个阈值，当相似度超过这一阈值，则把匹配得到的结果输出。人脸识别就是将待识别的人脸特征与已得到的人脸特征模板进行比较，根据相似程度对人脸的身份信息进行判断。这一过程又分为两类：一类是确认，是一对一进行图像比较的过程，另一类是辨认，是一对多进行图像匹配对比的过程。</p><h2 id="各个部分的简单介绍"><a href="#各个部分的简单介绍" class="headerlink" title="各个部分的简单介绍"></a>各个部分的简单介绍</h2><p><strong>每个部分只单单做简单介绍，可能只会提及少数常用的方法。</strong></p><h3 id="人脸图像的预处理"><a href="#人脸图像的预处理" class="headerlink" title="人脸图像的预处理"></a>人脸图像的预处理</h3><p>人脸识别的图像一般都是通过摄像机、照相机等摄录设备进行采集的，但由于采集的过程中的周围光照环境，强度的不同，所采用的照相设备性能有所不同不同，而导致所采集到的图像存在噪声，而且摄像角度和摄像距离的不同还会导致所得图像中人脸的大小，位置和角度不统一。为了保证识别系统中的对人脸图像的识别具有相同的质量，预处理就成为了人脸识别系统中必不可少的一个步骤。下面介绍几种经常用到的图像预处理方法。</p><p><strong>灰度变换</strong></p><p>灰度变换指的是根据需要的目标条件按一定变换关系逐点改变源图像中每一个像素的灰度值的一种方法。目的是为了改善画质，使图像的显示效果更加清晰。图像的灰度变换处理是图像增强处理技术中的一种非常基础、直接的空间域图像处理方法，也是图像数字化软件和图像显示软件的一个重要组成部分。</p><p>在人脸识别系统中我们所采集到的图像一般是彩色图像，但由于彩色图像中包含较大的数据量和信息量，所以直接对彩色图像进行处理不仅复杂而且耗时。而灰色图像虽然包含数据量较小，但包含的有用信息量却很大，更适合于人脸识别系统的应用。也因此，把彩色图像灰度化是人脸图像预处理的第一步。常用的灰度变换方法有线性变换，分段线性变换和非线性变换方法。</p><p>灰度化常用的经验公式: (其中R G B分别代表彩色图像RGB对应的值，grey则为对应的灰度值)</p><hr><p><strong>gray=0.39×R＋0.5×G＋0.11×B</strong></p><hr><p><img src="https://wx1.sinaimg.cn/mw690/006pSJjJly1goykqzvdf5j30n202swfj.jpg" alt="灰度处理流程"></p><p><strong>下面是灰度变换的方法(r为输入灰度值，s为输出灰度值)</strong></p><ol><li><p>​    线性变换-较多的是图像反转，图像反转得到的是图像的负片，能够有效的增强在图像暗区域的白色或者灰色细节。</p><hr><p><strong>S = 255-r</strong></p><hr></li></ol><ol start="2"><li><p>对数变换和反对数变换（其中c是一个常数）将源图像中<strong>范</strong>围较窄的低灰度值映射到范围较宽的灰度区间，同时将范围较宽的高灰度值区间映射为较窄的灰度区间，从而扩展了暗像素的值，压缩了高灰度的值，能够对图像中低灰度细节进行增强。</p><hr><p><strong>S = clog(1+r)</strong></p><hr></li></ol><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykr2xd6cj30ei0d2acd.jpg" alt="对数和反对数函数对应图像"></p><ol start="3"><li><p>幂律变换（其中c和γ为正常数[当γ&lt;1γ&lt;1时，γ的值越小，对图像低灰度值的扩展越明显；当γ&gt;1γ&gt;1时，γ的值越大，对图像高灰度值部分的扩展越明显。这样就能够显示更多的图像的低灰度或者高灰度细节。</p><hr><p><strong>S = （cr）γ次方</strong></p><hr></li></ol><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goykr4uq2ej30ff0ditbn.jpg" alt="幂律变换对应图像"></p><p><strong>几何矫正（具体内容略，只做简述）</strong></p><p>几何校正是用来解决角度问题，主要包括：</p><ul><li>图像的大小矫正。</li><li>图像的平移。</li><li>图像的翻转。</li><li>图像的旋转。</li></ul><p>常用的方法有两种：</p><ul><li>直接几何校正。</li><li>间接法几何校正。</li></ul><p><strong>图像滤波，对图像噪点进行处理</strong></p><p>由于人脸图像的采集环境往往是不理想的，比如存在光照强度的变换、采集设备性能的差异等等都会使采集到的图像中存在噪声，从而影响到采集到的图像质量。为了提升图像的质量水平，减少噪声对后期处理的不良影响，我们需要将图像中的噪声去除。目前常用的图像去噪方法可以分为两类：一类为对图像的全局处理，该类滤波需要事先对信号及噪声的统计模型有所了解，如Wiener滤波、卡尔曼滤波等；另一类为采用局部算子进行的滤波，如中值滤波、均值滤波等。</p><ol><li>  均值滤波。</li></ol><p>作为最简单的线性滤波器之一，其先对图像中目标像素进行局部平均,再把原来的像素值替换成局部平均值。邻域的大小对滤波效果也有很大的影响，邻域窗口的尺寸越大，滤波效果也会更好，但同时也会造成大量图像细节信息的损失，即图像将会变得模糊。</p><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykr79p6bj30c403vdgk.jpg" alt="均值滤波公式"></p><ol start="2"><li>中值滤波</li></ol><p>中值滤波也是一种常见的非线性滤波技术。该方法主要思想是把每一个像素点的灰度值设置为该像素点邻域内的所有像素点灰度值的中值，由于该方法不依赖于邻域中与典型值差别很大的值，所以在去除椒盐噪声和脉冲噪声的同时该方法还能够很好的保留人脸图像的边缘细节信息。</p><p>在图像中去3*3的矩阵，里面有9个像素点，我们将9个像素进行排序，最后将这个矩阵的中心点赋值为这九个像素的中值。如图所示。</p><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykr986kzj30jw0960uo.jpg" alt="中值滤波"></p><p><strong>图像特征提取方法</strong></p><ol><li><p>SIFT（尺度不变特征变换）</p><p>1.1 尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。</p><p>1.2 关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。</p><p>1.3 方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</p><p>1.4 关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。</p></li></ol><p>经过上述的步骤，尺度变化以及旋转等几何变换的影响就都能够被去除，如果还想再去除光照变化对其产生的影响，可以对特征点描述子进行长度归一化处理</p><ol start="2"><li>PCA-SIFT（主成分分析法结合SIFT）</li><li> GLOH（方向梯度直方图）</li></ol><p><strong>本次内容对于特征提取的方法不做讲解，因为特征提取的方法内容比较多，所以之后会对于不同的特征提取方法单独写篇文章进行具体探讨，这次只提出。</strong></p><p><strong>最后的特征匹配和验证</strong></p><p>提取的人脸图像的特征数据与数据库中存储的特征模板进行搜索匹配，通过设定一个阈值，当相似度超过这一阈值，则把匹配得到的结果输出。人脸识别就是将待识别的人脸特征与已得到的人脸特征模板进行比较，根据相似程度对人脸的身份信息进行判断。这一过程又分为两类：一类是确认，是一对一进行图像比较的过程，另一类是辨认，是一对多进行图像匹配对比的过程。</p><p>支持向量机（Support Vector Machine, SVM）是一类按<a href="https://baike.baidu.com/item/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/9820109">监督学习</a>（supervised learning）方式对数据进行<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB/15635322">二元分类</a>的广义线性分类器（generalized linear classifier），其<a href="https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E8%BE%B9%E7%95%8C/22778546">决策边界</a>是对学习样本求解的最大边距超平面（maximum-margin hyperplane） 。</p><p>SVM使用铰链损失函数（hinge loss）计算经验风险（empirical risk）并在求解系统中加入了正则化项以优化结构风险（structural risk），是一个具有稀疏性和稳健性的分类器  。SVM可以通过<a href="https://baike.baidu.com/item/%E6%A0%B8%E6%96%B9%E6%B3%95/1683712">核方法</a>（kernel method）进行非线性分类，是常见的核学习（kernel learning）方法之一  。</p><p>还有就是最常用的神经网络方法，但是神经网络内容也比较多，后面想要单独对神经网络的不同模型进行单独探讨，本次只提一下。</p><h2 id="由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。-如果内容对您有帮助或者对此感兴趣请继续关注哦！！！"><a href="#由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。-如果内容对您有帮助或者对此感兴趣请继续关注哦！！！" class="headerlink" title="由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。             如果内容对您有帮助或者对此感兴趣请继续关注哦！！！"></a>由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。             如果内容对您有帮助或者对此感兴趣请继续关注哦！！！</h2>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数质数的别致方法</title>
      <link href="2020/12/06/ji-shu-zhi-shu-de-bie-zhi-fang-fa/"/>
      <url>2020/12/06/ji-shu-zhi-shu-de-bie-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：-Leetcode-204-计数质数（统计所有小于非负整数n的质数数量）"><a href="#题目：-Leetcode-204-计数质数（统计所有小于非负整数n的质数数量）" class="headerlink" title="题目：  Leetcode - 204.计数质数（统计所有小于非负整数n的质数数量）"></a>题目：  Leetcode - 204.计数质数（统计所有小于非负整数n的质数数量）</h1><ul><li>方法一：枚举</li></ul><p>​    枚举判断每个数是不是质数考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x-1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。这个方法进一步优化可以的得到的结果是，如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在[2，sqrt(x)]区间中 ，因此只需要枚举这个区间中的所有数字即可，这样复杂度就从O(n)降低到了O(sqrt(n))。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">isPrime</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">+=</span> <span class="token function">isPrime</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>方法二：埃氏筛</li></ul><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（EratosthenesEratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们设 isPrime[i]表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> isPrime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykxgu7nmg30cd0a9q6x.gif" alt="示意图"></p><p>注意每次找当前素数 x 的倍数时，是从x平方开始的。因为如果 x &gt; 2，那么 2*x 肯定被素数 2 给过滤了，最小未被过滤的肯定是 x平方。</p><ul><li>线性筛  (了解原理即可，有点超纲)</li></ul><p>根据《算术基本定理》：每一个合数都可以以唯一形式被写成质数的乘积。换言之两个或两个以上质数的乘积，只可以组成一个合数n以内，从2起，遇质数放质数数组。遇数，该数与质数数组中每数相乘。</p><p>数为质数：质数 * 质数 = 合数。<br>数为合数：合数可拆为质数 * 质数 … = 质数 * 质数 … * 质数 = 合数。</p><p>只要作为因子的每个质数都不同，那么合数一定不同，不会重复当前数 能被 质数数组中的某质数 整除，当前数一定是包含 该质数 的合数合数拆分时，因子中，会出现 两个相同质数，不能保证合数不同质数数组中后面质数都比 该质数 大。该质数 * &gt;它的质数 = 合数后面一定会遇到。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> isPrime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        primes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> primes<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       isPrime<span class="token punctuation">[</span>i <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> primes<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线性筛时间复杂度和空间复杂度均为 : O(n)</strong></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo搭建个人网站的流程（算是小教程）</title>
      <link href="2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/"/>
      <url>2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-node-js-Git简单搭建个人Blog的记录"><a href="#使用Hexo-node-js-Git简单搭建个人Blog的记录" class="headerlink" title="使用Hexo + node.js + Git简单搭建个人Blog的记录"></a>使用Hexo + node.js + Git简单搭建个人Blog的记录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人Blog的用意主要是用于记录研究生期间的生活以及学习。</p><h2 id="搭建个人Blog的必备工具"><a href="#搭建个人Blog的必备工具" class="headerlink" title="搭建个人Blog的必备工具"></a>搭建个人Blog的必备工具</h2><ol><li><p>Hexo</p></li><li><p>Node.js</p></li><li><p>Git</p></li><li><p>代码编辑器  - 用于修改config的必要工具</p></li><li><p>一定的代码阅读能力（雾</p></li></ol><h2 id="第一步-Git的安装和基本使用"><a href="#第一步-Git的安装和基本使用" class="headerlink" title="第一步 Git的安装和基本使用"></a>第一步 Git的安装和基本使用</h2><p>我实在window平台上进行搭建和部署的，故直接再<a href="https://git-scm.com/downloads">Git官网</a>下载对应平台版本即可<img src="https://wx1.sinaimg.cn/mw690/006pSJjJly1goyj2zs79ij30j807wt9z.jpg" alt="官网下载"></p><p>下载后的exe可以说说是傻瓜包，直接next-next即可。</p><p>最后在开始菜单栏会出现表示安装成功，但是如果第一次安装的话必须要配置用户信息。<img src="https://wx3.sinaimg.cn/mw690/006pSJjJly1goyj338co7j30iq02kglq.jpg" alt="开始菜单显示"></p><p>要在git bash中配置用户的用户名和邮箱地址，具体操作如下</p><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token command">$ git config<span class="token parameter"> --global</span> user.name </span><span class="token string">"你的用户名"</span><span class="token command">$ git config<span class="token parameter"> --global</span> user.email </span><span class="token string">"你的邮箱地址"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果用了 <strong>–global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><p>全部操作完成之后算是Git部分完成了。</p><p><strong>恭喜你完成了第一步！！！（congratulation！！！）</strong></p><h2 id="第二部分-Node-js的安装和配置"><a href="#第二部分-Node-js的安装和配置" class="headerlink" title="第二部分 Node.js的安装和配置"></a>第二部分 Node.js的安装和配置</h2><p>照例第一步node.js官方中文网站下载安装<a href="https://nodejs.org/zh-cn/">node.js官网</a>(建议安装长期支持的稳定版本)</p><p><img src="https://wx1.sinaimg.cn/mw690/006pSJjJly1goyj35snjqj30p009ogmd.jpg" alt="node.js官网"></p><p>安装过程省略基本全程next-next（如果安装出现特定的问题建议百度哦）</p><p>Node.js继承了npm工具，全部安装结束之后为了验证安装是否成，进入到cmd(win+r)中输入如图中的指令，如出现如图中的node和npm版本号则说明安装成功。</p><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goyj390t47j30hq09c0t8.jpg" alt="显示版本号"></p><p>到这里则说明node和npm安装成功！ congratulation！ </p><h2 id="第三部分-基于node-js安装Hexo"><a href="#第三部分-基于node-js安装Hexo" class="headerlink" title="第三部分 基于node.js安装Hexo"></a>第三部分 基于node.js安装Hexo</h2><p>因为我是win平台，所以可以省略的cmd指令就用win有好的GUI操作来代替。</p><p>首先创建一个保存所有的工程文件的文件夹，在win平台操作则非常简单，直接选择一个盘符中创建一个文件夹。再打开CMD（接下来就是cmd指令居多），通过cd指令切换到创建好的文件夹路径中。通过Cmd或者git bash 输入下面的指令来安装 。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成之后再用指令来查看版本即可知道安装成功与否。</p><pre class="line-numbers language-none"><code class="language-none">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现了安装过程异常缓慢或者直接卡主不动的情况下其实是正常的，我们可以用npm安装淘宝的cnpm管理器，用淘宝的源会快一些。指令如下。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装成功之后，继续在这个路径下初始hexo生成和初始化博客，指令如下。</p><pre class="line-numbers language-none"><code class="language-none">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待整个init的过程完成之后在生成的文件夹之中会生成许多的配置文件，我们之后再继续讲解配置网站内容的部分。</p><p>接下来执行以下的操作来在本机上启动blog服务。</p><pre class="line-numbers language-none"><code class="language-none">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在cmd最后会出现用于访问blog的地址为localhost:4000   也就是本机4000端口上。</p><p>打开浏览器输入url即可访问到启动好的blog，不过都是Hexo初始化的主题和内容，还有一篇初始的博客，内容为Hexo的基本操作  就是 hexo g hexo s hexo clean和写新博文hexo new “name”等等的一系列指令。页面如下。</p><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goyj3bthj7j30s40dswjd.jpg" alt="默认界面"></p><p><strong>这只是最基本的布局和样式，如果想要让自己的blog更加好看优美需要额外的配置，让页面更好看的操作教程我会再单独的出一篇blog，本次只单独讲最简单启动和部署。</strong></p><h2 id="第四部分-将自己的网站托管到Git上"><a href="#第四部分-将自己的网站托管到Git上" class="headerlink" title="第四部分 将自己的网站托管到Git上"></a>第四部分 将自己的网站托管到Git上</h2><p>之前的操作下来只能在本地启动Hexo的服务，要打开也只能通过本机的localhost 4000端口上。</p><p>托管在第三方上可以让自己的网站Blog随时随地的访问，我们选择把它托管在最受欢迎的Github上，这也是我们首先安装git的原因。</p><p>首先第一步是在web版的github上进入到自己的个人界面新建一个仓库(Respositories)，新建的过程中要把仓库的名称建立得和自己ID一样才可以，具体的格式为       **你的用户ID.github.io   **，穿件完成之后接下来就是要把自己的网站部署到刚刚创建的仓库中。</p><p><strong>不过安装的过程中还要依赖一个额外的插件，依赖这个插件才能完成简单的部署。需要再次使用之前安装的cnpm来完成快速的安装 hexo-deloyer-git</strong> 。  操作的代码如下。</p><pre class="line-numbers language-none"><code class="language-none">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下里等待安装完成即可，倘若是之前切换了淘宝的源安装可能就很快，但是直接用npm可能会很慢或者卡主不动。</p><p>接下来就是配置这个插件。<strong>首先在blog的根目录下打开 _config.yml配置文件找到deployment选项下 修改type为git 再添加repo项，值为你在github上新创建的仓库url,还要选择你上传到的branch</strong>。具体如下。</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy:  type: &#39;git&#39;  repo: https:&#x2F;&#x2F;github.com&quot;你的仓库“  branch : main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里有个小插曲： github在2020年10月分把原本的默认分支master修改为了main（原因呢，是在阿妹你看因为黑人小伙子弗洛伊德之死引发的大规模抗议使得人们看到master容易联想到不好的东西，所以改为了main）</strong>。</p><p>配置完成之后就是部署你的所有文件到github</p><p>使用cmd指令如下即可</p><pre class="line-numbers language-none"><code class="language-none">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后可以在你的github页面对应仓库看到新的提交改动。</p><p>接下来使用**https://“仓库名.github.io/**即可访问到你部署在github上的blog了。</p><p><strong>congratulation！   你已经完成了你的Blog！   在之后我会继续给出如何写新的博文以及修改blog主题和样式让你的blog更加好看，请继续跟进和关注本Blog！！！</strong></p><p><strong>可能会用到的Hexo指令</strong></p><pre class="line-numbers language-none"><code class="language-none">hexo clean   # hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo g       #生成网站静态文件到默认设置的 public 文件夹。hexo s #启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;。hexo d #自动生成网站静态文件，并部署到设定的仓库。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。"><a href="#如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。" class="headerlink" title="如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。"></a>如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。</h2>]]></content>
      
      
      <categories>
          
          <category> 个人Blog </category>
          
          <category> 博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Blog教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
