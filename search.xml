<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的</title>
      <link href="2021/03/27/wo-de/"/>
      <url>2021/03/27/wo-de/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人脸识别入门内容简介</title>
      <link href="2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/"/>
      <url>2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="（个人向）人脸识别，图像处理内容入门学习。"><a href="#（个人向）人脸识别，图像处理内容入门学习。" class="headerlink" title="（个人向）人脸识别，图像处理内容入门学习。"></a>（个人向）人脸识别，图像处理内容入门学习。</h1><h2 id="背景及意义"><a href="#背景及意义" class="headerlink" title="背景及意义"></a>背景及意义</h2><p>人脸识别，是基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，利用人脸固有的特征信息进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。是模式识别和人工智能最广泛的应用之一，通常也叫做人像识别、面部识别。</p><h2 id="人脸识别过程简述"><a href="#人脸识别过程简述" class="headerlink" title="人脸识别过程简述"></a>人脸识别过程简述</h2><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goykslj28yj30if0jcdj4.jpg" alt="人脸识别流程图"></p><ol><li>人脸图像采集及检测</li></ol><p>人脸图像采集,不同的人脸图像都能通过图像采集设备采集下来，比如静态的图像、动态图像、不同的位置、不同表情等方面都可以得到很好的采集。人脸检测，在实际中主要用于人脸识别的预处理，即就是在图像中准确标出人脸的位置和大小，人脸图像中包含的模式特征十分丰富，如直方图特征、颜色特征、模板特征、结构特征等。人脸检测就是把这其中有用的信息挑出来，并利用这些特征实现人脸检测。</p><ol start="2"><li>人脸图像预处理</li></ol><p>这是以人脸检测结果为基础的，对图像进行处理并最终服务于特征提取的过程。系统获取的原始图像由于受到各种条件的限制和随机干扰，往往不能直接使用，必须在图像处理的早期阶段对它进行灰度校正、噪声过滤等图像预处理。对于人脸图像而言，其预处理过程主要包括人脸图像的光线补偿、灰度变换、直方图均衡化、归一化、几何校正、滤波以及锐化等。</p><ol start="3"><li>人脸图像特征提取</li></ol><p>人脸图像特征提取：人脸识别系统可使用的特征通常分为视觉特征、像素统计特征、人脸图像变换系数特征、人脸图像代数特征等。人脸特征提取就是针对人脸的某些特征进行的。人脸特征提取，也称人脸表征，它是对人脸进行特征建模的过程。人脸特征提取的方法归纳起来分为两大类：一种是基于知识的表征方法；另外一种是基于代数特征或统计学习的表征方法。</p><ol start="4"><li>人脸图像匹配与识别</li></ol><p>人脸图像匹配与识别：提取的人脸图像的特征数据与数据库中存储的特征模板进行搜索匹配，通过设定一个阈值，当相似度超过这一阈值，则把匹配得到的结果输出。人脸识别就是将待识别的人脸特征与已得到的人脸特征模板进行比较，根据相似程度对人脸的身份信息进行判断。这一过程又分为两类：一类是确认，是一对一进行图像比较的过程，另一类是辨认，是一对多进行图像匹配对比的过程。</p><h2 id="各个部分的简单介绍"><a href="#各个部分的简单介绍" class="headerlink" title="各个部分的简单介绍"></a>各个部分的简单介绍</h2><p><strong>每个部分只单单做简单介绍，可能只会提及少数常用的方法。</strong></p><h3 id="人脸图像的预处理"><a href="#人脸图像的预处理" class="headerlink" title="人脸图像的预处理"></a>人脸图像的预处理</h3><p>人脸识别的图像一般都是通过摄像机、照相机等摄录设备进行采集的，但由于采集的过程中的周围光照环境，强度的不同，所采用的照相设备性能有所不同不同，而导致所采集到的图像存在噪声，而且摄像角度和摄像距离的不同还会导致所得图像中人脸的大小，位置和角度不统一。为了保证识别系统中的对人脸图像的识别具有相同的质量，预处理就成为了人脸识别系统中必不可少的一个步骤。下面介绍几种经常用到的图像预处理方法。</p><p><strong>灰度变换</strong></p><p>灰度变换指的是根据需要的目标条件按一定变换关系逐点改变源图像中每一个像素的灰度值的一种方法。目的是为了改善画质，使图像的显示效果更加清晰。图像的灰度变换处理是图像增强处理技术中的一种非常基础、直接的空间域图像处理方法，也是图像数字化软件和图像显示软件的一个重要组成部分。</p><p>在人脸识别系统中我们所采集到的图像一般是彩色图像，但由于彩色图像中包含较大的数据量和信息量，所以直接对彩色图像进行处理不仅复杂而且耗时。而灰色图像虽然包含数据量较小，但包含的有用信息量却很大，更适合于人脸识别系统的应用。也因此，把彩色图像灰度化是人脸图像预处理的第一步。常用的灰度变换方法有线性变换，分段线性变换和非线性变换方法。</p><p>灰度化常用的经验公式: (其中R G B分别代表彩色图像RGB对应的值，grey则为对应的灰度值)</p><hr><p><strong>gray=0.39×R＋0.5×G＋0.11×B</strong></p><hr><p><img src="https://wx1.sinaimg.cn/mw690/006pSJjJly1goykqzvdf5j30n202swfj.jpg" alt="灰度处理流程"></p><p><strong>下面是灰度变换的方法(r为输入灰度值，s为输出灰度值)</strong></p><ol><li><p>​    线性变换-较多的是图像反转，图像反转得到的是图像的负片，能够有效的增强在图像暗区域的白色或者灰色细节。</p><hr><p><strong>S = 255-r</strong></p><hr></li></ol><ol start="2"><li><p>对数变换和反对数变换（其中c是一个常数）将源图像中<strong>范</strong>围较窄的低灰度值映射到范围较宽的灰度区间，同时将范围较宽的高灰度值区间映射为较窄的灰度区间，从而扩展了暗像素的值，压缩了高灰度的值，能够对图像中低灰度细节进行增强。</p><hr><p><strong>S = clog(1+r)</strong></p><hr></li></ol><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykr2xd6cj30ei0d2acd.jpg" alt="对数和反对数函数对应图像"></p><ol start="3"><li><p>幂律变换（其中c和γ为正常数[当γ&lt;1γ&lt;1时，γ的值越小，对图像低灰度值的扩展越明显；当γ&gt;1γ&gt;1时，γ的值越大，对图像高灰度值部分的扩展越明显。这样就能够显示更多的图像的低灰度或者高灰度细节。</p><hr><p><strong>S = （cr）γ次方</strong></p><hr></li></ol><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goykr4uq2ej30ff0ditbn.jpg" alt="幂律变换对应图像"></p><p><strong>几何矫正（具体内容略，只做简述）</strong></p><p>几何校正是用来解决角度问题，主要包括：</p><ul><li>图像的大小矫正。</li><li>图像的平移。</li><li>图像的翻转。</li><li>图像的旋转。</li></ul><p>常用的方法有两种：</p><ul><li>直接几何校正。</li><li>间接法几何校正。</li></ul><p><strong>图像滤波，对图像噪点进行处理</strong></p><p>由于人脸图像的采集环境往往是不理想的，比如存在光照强度的变换、采集设备性能的差异等等都会使采集到的图像中存在噪声，从而影响到采集到的图像质量。为了提升图像的质量水平，减少噪声对后期处理的不良影响，我们需要将图像中的噪声去除。目前常用的图像去噪方法可以分为两类：一类为对图像的全局处理，该类滤波需要事先对信号及噪声的统计模型有所了解，如Wiener滤波、卡尔曼滤波等；另一类为采用局部算子进行的滤波，如中值滤波、均值滤波等。</p><ol><li>  均值滤波。</li></ol><p>作为最简单的线性滤波器之一，其先对图像中目标像素进行局部平均,再把原来的像素值替换成局部平均值。邻域的大小对滤波效果也有很大的影响，邻域窗口的尺寸越大，滤波效果也会更好，但同时也会造成大量图像细节信息的损失，即图像将会变得模糊。</p><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykr79p6bj30c403vdgk.jpg" alt="均值滤波公式"></p><ol start="2"><li>中值滤波</li></ol><p>中值滤波也是一种常见的非线性滤波技术。该方法主要思想是把每一个像素点的灰度值设置为该像素点邻域内的所有像素点灰度值的中值，由于该方法不依赖于邻域中与典型值差别很大的值，所以在去除椒盐噪声和脉冲噪声的同时该方法还能够很好的保留人脸图像的边缘细节信息。</p><p>在图像中去3*3的矩阵，里面有9个像素点，我们将9个像素进行排序，最后将这个矩阵的中心点赋值为这九个像素的中值。如图所示。</p><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykr986kzj30jw0960uo.jpg" alt="中值滤波"></p><p><strong>图像特征提取方法</strong></p><ol><li><p>SIFT（尺度不变特征变换）</p><p>1.1 尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。</p><p>1.2 关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。</p><p>1.3 方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</p><p>1.4 关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。</p></li></ol><p>经过上述的步骤，尺度变化以及旋转等几何变换的影响就都能够被去除，如果还想再去除光照变化对其产生的影响，可以对特征点描述子进行长度归一化处理</p><ol start="2"><li>PCA-SIFT（主成分分析法结合SIFT）</li><li> GLOH（方向梯度直方图）</li></ol><p><strong>本次内容对于特征提取的方法不做讲解，因为特征提取的方法内容比较多，所以之后会对于不同的特征提取方法单独写篇文章进行具体探讨，这次只提出。</strong></p><p><strong>最后的特征匹配和验证</strong></p><p>提取的人脸图像的特征数据与数据库中存储的特征模板进行搜索匹配，通过设定一个阈值，当相似度超过这一阈值，则把匹配得到的结果输出。人脸识别就是将待识别的人脸特征与已得到的人脸特征模板进行比较，根据相似程度对人脸的身份信息进行判断。这一过程又分为两类：一类是确认，是一对一进行图像比较的过程，另一类是辨认，是一对多进行图像匹配对比的过程。</p><p>支持向量机（Support Vector Machine, SVM）是一类按<a href="https://baike.baidu.com/item/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/9820109">监督学习</a>（supervised learning）方式对数据进行<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB/15635322">二元分类</a>的广义线性分类器（generalized linear classifier），其<a href="https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E8%BE%B9%E7%95%8C/22778546">决策边界</a>是对学习样本求解的最大边距超平面（maximum-margin hyperplane） 。</p><p>SVM使用铰链损失函数（hinge loss）计算经验风险（empirical risk）并在求解系统中加入了正则化项以优化结构风险（structural risk），是一个具有稀疏性和稳健性的分类器  。SVM可以通过<a href="https://baike.baidu.com/item/%E6%A0%B8%E6%96%B9%E6%B3%95/1683712">核方法</a>（kernel method）进行非线性分类，是常见的核学习（kernel learning）方法之一  。</p><p>还有就是最常用的神经网络方法，但是神经网络内容也比较多，后面想要单独对神经网络的不同模型进行单独探讨，本次只提一下。</p><h2 id="由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。-如果内容对您有帮助或者对此感兴趣请继续关注哦！！！"><a href="#由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。-如果内容对您有帮助或者对此感兴趣请继续关注哦！！！" class="headerlink" title="由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。             如果内容对您有帮助或者对此感兴趣请继续关注哦！！！"></a>由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。             如果内容对您有帮助或者对此感兴趣请继续关注哦！！！</h2>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数质数的别致方法</title>
      <link href="2020/12/06/ji-shu-zhi-shu-de-bie-zhi-fang-fa/"/>
      <url>2020/12/06/ji-shu-zhi-shu-de-bie-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：-Leetcode-204-计数质数（统计所有小于非负整数n的质数数量）"><a href="#题目：-Leetcode-204-计数质数（统计所有小于非负整数n的质数数量）" class="headerlink" title="题目：  Leetcode - 204.计数质数（统计所有小于非负整数n的质数数量）"></a>题目：  Leetcode - 204.计数质数（统计所有小于非负整数n的质数数量）</h1><ul><li>方法一：枚举</li></ul><p>​    枚举判断每个数是不是质数考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x-1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。这个方法进一步优化可以的得到的结果是，如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在[2，sqrt(x)]区间中 ，因此只需要枚举这个区间中的所有数字即可，这样复杂度就从O(n)降低到了O(sqrt(n))。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">isPrime</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">+=</span> <span class="token function">isPrime</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>方法二：埃氏筛</li></ul><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（EratosthenesEratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们设 isPrime[i]表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> isPrime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://wx2.sinaimg.cn/mw690/006pSJjJly1goykxgu7nmg30cd0a9q6x.gif" alt="示意图"></p><p>注意每次找当前素数 x 的倍数时，是从x平方开始的。因为如果 x &gt; 2，那么 2*x 肯定被素数 2 给过滤了，最小未被过滤的肯定是 x平方。</p><ul><li>线性筛  (了解原理即可，有点超纲)</li></ul><p>根据《算术基本定理》：每一个合数都可以以唯一形式被写成质数的乘积。换言之两个或两个以上质数的乘积，只可以组成一个合数n以内，从2起，遇质数放质数数组。遇数，该数与质数数组中每数相乘。</p><p>数为质数：质数 * 质数 = 合数。<br>数为合数：合数可拆为质数 * 质数 … = 质数 * 质数 … * 质数 = 合数。</p><p>只要作为因子的每个质数都不同，那么合数一定不同，不会重复当前数 能被 质数数组中的某质数 整除，当前数一定是包含 该质数 的合数合数拆分时，因子中，会出现 两个相同质数，不能保证合数不同质数数组中后面质数都比 该质数 大。该质数 * &gt;它的质数 = 合数后面一定会遇到。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> isPrime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        primes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> primes<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       isPrime<span class="token punctuation">[</span>i <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> primes<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线性筛时间复杂度和空间复杂度均为 : O(n)</strong></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo搭建个人网站的流程（算是小教程）</title>
      <link href="2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/"/>
      <url>2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-node-js-Git简单搭建个人Blog的记录"><a href="#使用Hexo-node-js-Git简单搭建个人Blog的记录" class="headerlink" title="使用Hexo + node.js + Git简单搭建个人Blog的记录"></a>使用Hexo + node.js + Git简单搭建个人Blog的记录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人Blog的用意主要是用于记录研究生期间的生活以及学习。</p><h2 id="搭建个人Blog的必备工具"><a href="#搭建个人Blog的必备工具" class="headerlink" title="搭建个人Blog的必备工具"></a>搭建个人Blog的必备工具</h2><ol><li><p>Hexo</p></li><li><p>Node.js</p></li><li><p>Git</p></li><li><p>代码编辑器  - 用于修改config的必要工具</p></li><li><p>一定的代码阅读能力（雾</p></li></ol><h2 id="第一步-Git的安装和基本使用"><a href="#第一步-Git的安装和基本使用" class="headerlink" title="第一步 Git的安装和基本使用"></a>第一步 Git的安装和基本使用</h2><p>我实在window平台上进行搭建和部署的，故直接再<a href="https://git-scm.com/downloads">Git官网</a>下载对应平台版本即可<img src="https://wx1.sinaimg.cn/mw690/006pSJjJly1goyj2zs79ij30j807wt9z.jpg" alt="官网下载"></p><p>下载后的exe可以说说是傻瓜包，直接next-next即可。</p><p>最后在开始菜单栏会出现表示安装成功，但是如果第一次安装的话必须要配置用户信息。<img src="https://wx3.sinaimg.cn/mw690/006pSJjJly1goyj338co7j30iq02kglq.jpg" alt="开始菜单显示"></p><p>要在git bash中配置用户的用户名和邮箱地址，具体操作如下</p><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token command">$ git config<span class="token parameter"> --global</span> user.name </span><span class="token string">"你的用户名"</span><span class="token command">$ git config<span class="token parameter"> --global</span> user.email </span><span class="token string">"你的邮箱地址"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果用了 <strong>–global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><p>全部操作完成之后算是Git部分完成了。</p><p><strong>恭喜你完成了第一步！！！（congratulation！！！）</strong></p><h2 id="第二部分-Node-js的安装和配置"><a href="#第二部分-Node-js的安装和配置" class="headerlink" title="第二部分 Node.js的安装和配置"></a>第二部分 Node.js的安装和配置</h2><p>照例第一步node.js官方中文网站下载安装<a href="https://nodejs.org/zh-cn/">node.js官网</a>(建议安装长期支持的稳定版本)</p><p><img src="https://wx1.sinaimg.cn/mw690/006pSJjJly1goyj35snjqj30p009ogmd.jpg" alt="node.js官网"></p><p>安装过程省略基本全程next-next（如果安装出现特定的问题建议百度哦）</p><p>Node.js继承了npm工具，全部安装结束之后为了验证安装是否成，进入到cmd(win+r)中输入如图中的指令，如出现如图中的node和npm版本号则说明安装成功。</p><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goyj390t47j30hq09c0t8.jpg" alt="显示版本号"></p><p>到这里则说明node和npm安装成功！ congratulation！ </p><h2 id="第三部分-基于node-js安装Hexo"><a href="#第三部分-基于node-js安装Hexo" class="headerlink" title="第三部分 基于node.js安装Hexo"></a>第三部分 基于node.js安装Hexo</h2><p>因为我是win平台，所以可以省略的cmd指令就用win有好的GUI操作来代替。</p><p>首先创建一个保存所有的工程文件的文件夹，在win平台操作则非常简单，直接选择一个盘符中创建一个文件夹。再打开CMD（接下来就是cmd指令居多），通过cd指令切换到创建好的文件夹路径中。通过Cmd或者git bash 输入下面的指令来安装 。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成之后再用指令来查看版本即可知道安装成功与否。</p><pre class="line-numbers language-none"><code class="language-none">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现了安装过程异常缓慢或者直接卡主不动的情况下其实是正常的，我们可以用npm安装淘宝的cnpm管理器，用淘宝的源会快一些。指令如下。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装成功之后，继续在这个路径下初始hexo生成和初始化博客，指令如下。</p><pre class="line-numbers language-none"><code class="language-none">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待整个init的过程完成之后在生成的文件夹之中会生成许多的配置文件，我们之后再继续讲解配置网站内容的部分。</p><p>接下来执行以下的操作来在本机上启动blog服务。</p><pre class="line-numbers language-none"><code class="language-none">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在cmd最后会出现用于访问blog的地址为localhost:4000   也就是本机4000端口上。</p><p>打开浏览器输入url即可访问到启动好的blog，不过都是Hexo初始化的主题和内容，还有一篇初始的博客，内容为Hexo的基本操作  就是 hexo g hexo s hexo clean和写新博文hexo new “name”等等的一系列指令。页面如下。</p><p><img src="https://wx4.sinaimg.cn/mw690/006pSJjJly1goyj3bthj7j30s40dswjd.jpg" alt="默认界面"></p><p><strong>这只是最基本的布局和样式，如果想要让自己的blog更加好看优美需要额外的配置，让页面更好看的操作教程我会再单独的出一篇blog，本次只单独讲最简单启动和部署。</strong></p><h2 id="第四部分-将自己的网站托管到Git上"><a href="#第四部分-将自己的网站托管到Git上" class="headerlink" title="第四部分 将自己的网站托管到Git上"></a>第四部分 将自己的网站托管到Git上</h2><p>之前的操作下来只能在本地启动Hexo的服务，要打开也只能通过本机的localhost 4000端口上。</p><p>托管在第三方上可以让自己的网站Blog随时随地的访问，我们选择把它托管在最受欢迎的Github上，这也是我们首先安装git的原因。</p><p>首先第一步是在web版的github上进入到自己的个人界面新建一个仓库(Respositories)，新建的过程中要把仓库的名称建立得和自己ID一样才可以，具体的格式为       **你的用户ID.github.io   **，穿件完成之后接下来就是要把自己的网站部署到刚刚创建的仓库中。</p><p><strong>不过安装的过程中还要依赖一个额外的插件，依赖这个插件才能完成简单的部署。需要再次使用之前安装的cnpm来完成快速的安装 hexo-deloyer-git</strong> 。  操作的代码如下。</p><pre class="line-numbers language-none"><code class="language-none">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下里等待安装完成即可，倘若是之前切换了淘宝的源安装可能就很快，但是直接用npm可能会很慢或者卡主不动。</p><p>接下来就是配置这个插件。<strong>首先在blog的根目录下打开 _config.yml配置文件找到deployment选项下 修改type为git 再添加repo项，值为你在github上新创建的仓库url,还要选择你上传到的branch</strong>。具体如下。</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy:  type: &#39;git&#39;  repo: https:&#x2F;&#x2F;github.com&quot;你的仓库“  branch : main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里有个小插曲： github在2020年10月分把原本的默认分支master修改为了main（原因呢，是在阿妹你看因为黑人小伙子弗洛伊德之死引发的大规模抗议使得人们看到master容易联想到不好的东西，所以改为了main）</strong>。</p><p>配置完成之后就是部署你的所有文件到github</p><p>使用cmd指令如下即可</p><pre class="line-numbers language-none"><code class="language-none">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后可以在你的github页面对应仓库看到新的提交改动。</p><p>接下来使用**https://“仓库名.github.io/**即可访问到你部署在github上的blog了。</p><p><strong>congratulation！   你已经完成了你的Blog！   在之后我会继续给出如何写新的博文以及修改blog主题和样式让你的blog更加好看，请继续跟进和关注本Blog！！！</strong></p><p><strong>可能会用到的Hexo指令</strong></p><pre class="line-numbers language-none"><code class="language-none">hexo clean   # hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo g       #生成网站静态文件到默认设置的 public 文件夹。hexo s #启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;。hexo d #自动生成网站静态文件，并部署到设定的仓库。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。"><a href="#如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。" class="headerlink" title="如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。"></a>如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。</h2>]]></content>
      
      
      <categories>
          
          <category> 个人Blog </category>
          
          <category> 博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Blog教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
