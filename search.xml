<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端笔记 - HTTP与HTTPS</title>
      <link href="2021/04/04/qian-duan-bi-ji-http-yu-https/"/>
      <url>2021/04/04/qian-duan-bi-ji-http-yu-https/</url>
      
        <content type="html"><![CDATA[<h2 id="前提：本篇内容均为网络收集的各种知识再加上自己的见解杂糅而成，主要用于知识回顾。"><a href="#前提：本篇内容均为网络收集的各种知识再加上自己的见解杂糅而成，主要用于知识回顾。" class="headerlink" title="前提：本篇内容均为网络收集的各种知识再加上自己的见解杂糅而成，主要用于知识回顾。"></a>前提：本篇内容均为网络收集的各种知识再加上自己的见解杂糅而成，主要用于知识回顾。</h2><h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><h4 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h4><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传<br>输层协议，保证了数据传输的可靠性。</p><p>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p><p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护<br>一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP<br>连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a<br>live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持<br>同时建立 6 个持久连接。</p><h4 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 请求报文的格式如下：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http">GET / HTTP/1.1<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)<span class="token header-name keyword">Accept:</span> */*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这<br>个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应<br>中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但<br>更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">文档</a>。</p><h4 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 响应报文的格式如下：</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.0 200 OKContent-Type: text&#x2F;plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt;  &lt;body&gt;Hello World&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。</p><p>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。</p><p>实体部分是报文的主要部分，它包含了所请求的对象。</p><p>常见的状态有</p><p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改、<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误。</p><p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><p>更多关于状态码的可以查看：</p><p><a href="http://www.runoob.com/http/http-status-codes.html">《HTTP 状态码》</a></p><h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设<br>置，区别在于请求首部和响应首部。</p><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修<br>改时间。</p><p>更多关于首部的资料可以查看：</p><p><a href="https://www.cnblogs.com/jycboy/p/http_head.html">《HTTP 首部字段详细介绍》</a></p><p><a href="https://blog.csdn.net/qq_34289537/article/details/52971516">《图解 HTTP》</a></p><h4 id="HTTP-1-1-协议缺点"><a href="#HTTP-1-1-协议缺点" class="headerlink" title="HTTP/1.1 协议缺点"></a>HTTP/1.1 协议缺点</h4><p>HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序<br>是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许<br>多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他<br>资源请求完成后才能发起请求。</p><p>为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。</p><h3 id="HTTP-2-协议"><a href="#HTTP-2-协议" class="headerlink" title="HTTP/2 协议"></a>HTTP/2 协议</h3><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明<br>可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</p><p>HTTP/2 主要有以下新的特性：</p><h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是<br>二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。<br>帧的概念是它实现多路复用的基础。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回<br>应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的<br>请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每<br>个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p><h4 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h4><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是<br>重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，<br>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引<br>号，这样就能提高速度了。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源<br>，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用<br>SSE 等方式向客户端发送即时数据的推送是不同的。</p><p>详细的资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">《HTTP/2 服务器推送（Server Push）教程》</a></p><h4 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h4><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵<br>守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都<br>会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p><h4 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h4><p>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC<br>协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/302412059">《如何看待 HTTP/3 ？》</a></p><h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><h4 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h4><ol><li><p>HTTP 报文使用明文方式发送，可能被第三方窃听。</p></li><li><p>HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</p></li><li><p>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</p></li></ol><h4 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h4><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/<br>SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立<br>刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p><h4 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h4><ol><li><p>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</p></li><li><p>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p></li><li><p>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服<br>务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</p></li><li><p>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</p></li><li><p>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥<br>来加密信息。</p></li></ol><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>TLS 的握手过程主要用到了三个方法来保证传输的安全。</p><p>首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就<br>是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。<br>这就要用到非对称加密的方法。</p><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只<br>有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，<br>都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加<br>密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以<br>非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存<br>在的问题。</p><p>但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取<br>了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥<br>解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成<br>一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合<br>在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证<br>处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改<br>了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有<br>这样我们才能保证数据的安全。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA">《一个故事讲完 https》</a><br><a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS 协议运行机制的概述》</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 SSL/TLS 协议》</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA 算法原理（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">《RSA 算法原理（二）》</a></p><h2 id="TCP-和-UDP-之间的区别"><a href="#TCP-和-UDP-之间的区别" class="headerlink" title="TCP 和 UDP 之间的区别"></a>TCP 和 UDP 之间的区别</h2><p>TCP：传输控制协议 UDP：用户数据报协议</p><ol><li>TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接；</li><li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。</li><li>TCP 是面向字节流，UDP 面向报文；</li><li>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多；</li><li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节；</li></ol><h2 id="TCP-三次握手的过程"><a href="#TCP-三次握手的过程" class="headerlink" title="TCP 三次握手的过程"></a>TCP 三次握手的过程</h2><p><img src="/2021/04/04/qian-duan-bi-ji-http-yu-https/2.png" alt="三次握手"></p><p>第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的<br>随机数。它代表的是客户端数据的初始序号。</p><p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向<br>客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，<br>同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加<br>一。</p><p>第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务<br>器端的报文段的确认。第三次握手可以在报文段中携带数据。</p><p>在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。<br>第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否<br>已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/24853633">《TCP 为什么是三次握手，而不是两次或四次？》</a><br><a href="https://blog.csdn.net/qzcsu/article/details/72861891">《TCP 的三次握手与四次挥手》</a></p><h2 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h2><p><img src="/2021/04/04/qian-duan-bi-ji-http-yu-https/3.png" alt="四次挥手"></p><p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p><p>第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的<br>连接。发送后客户端进入 FIN_WAIT_1 状态。</p><p>第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的<br>请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务<br>器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</p><p>第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS<br>T_ACK 状态。</p><p>第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，<br>这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到<br>服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被<br>释放了。</p><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代<br>表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器<br>端不能正常关闭。</p><h2 id="HTTP-请求的方式"><a href="#HTTP-请求的方式" class="headerlink" title="HTTP 请求的方式"></a>HTTP 请求的方式</h2><ol><li>GET：请求指定的页面信息，并返回实体主体。</li><li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</li><li>PUT：从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE：请求服务器删除指定的页面。</li><li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS：允许客户端查看服务器的性能。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li></ol><h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><p>两者本质上都是 TCP 链接</p><ol><li>get 参数通过 url 传递，post 放在请求体 (request body) 中。</li><li>get 请求在 url 中传递的参数是有长度限制的，而 post 没有。</li><li>get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。</li><li>get 请求只能进行 url 编码，而 post 支持多种编码方式。</li><li>get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。</li><li>get 产生一个 TCP 数据包；post 产生两个 TCP 数据包。<br>对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；<br>而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP&amp;&amp;HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客图片不显示问题的解决</title>
      <link href="2021/03/31/guan-yu-bo-ke-tu-pian-bu-xian-shi-wen-ti-de-jie-jue/"/>
      <url>2021/03/31/guan-yu-bo-ke-tu-pian-bu-xian-shi-wen-ti-de-jie-jue/</url>
      
        <content type="html"><![CDATA[<h1 id="博客图片为啥不显示？"><a href="#博客图片为啥不显示？" class="headerlink" title="博客图片为啥不显示？"></a>博客图片为啥不显示？</h1><h2 id="新浪微博防盗链"><a href="#新浪微博防盗链" class="headerlink" title="新浪微博防盗链"></a>新浪微博防盗链</h2><p>之前图方便把图片直接传新浪微博复制链接写入到Markdown中。</p><p>新浪图床是一个非常好的图床，虽然新浪到处被喷，但是在图片外链上一直没采取防盗链措施，近日才开启了防盗链措施。众所周知，图片的加载是需要流量的，但如果服务器的带宽不够大，那么网站的加载速度明显降低，用户的体验就不好，所以不少的小网站站长，会将图片以外链的方式存到新浪图床中。</p><p><img src="/2021/03/31/guan-yu-bo-ke-tu-pian-bu-xian-shi-wen-ti-de-jie-jue/p1.png" alt="403报错"></p><p>在由防盗链的情况下，打开博客，引自新浪微博的图片不显示，console报Http403错误。新浪之前一直被当做免费图床，还是会占用不少的资源，所以在引图片的时候会去溯源是什么网站来请求图片，如果不是新浪白名单的网站IP来请求，新浪服务器就不响应对应资源。</p><h3 id="啥是防盗链？"><a href="#啥是防盗链？" class="headerlink" title="啥是防盗链？"></a>啥是防盗链？</h3><p><strong>新浪的防盗链是Referer 防盗链，这种类型的防盗链方式，非常常见也很简单</strong></p><p><code>Referer</code>在<code>HTTP</code>协议里有特殊的用途，当浏览器向服务器发送请求时，一般会带上<code>Referer</code>头，告知服务器该请求是从哪个页面链接过来的。<code>Referer</code>经常被用于页面访问统计、图片防盗链等。</p><p>当一个<code>HTTP</code>请求发送到<code>CDN</code>服务器后，<code>CDN</code>服务器检查客户<code>URL</code>中所携带的<code>Referer</code>字段的信息，禁止或者允许符合特定规则（支持正则匹配）</p><p>常见<code>CDN</code>服务就会提供此类型的防盗链功能，典型特征是：不能通过其他网站访问，但是直接访问图片资源的<code>URL</code>是可以下载、查看。</p><h3 id="如何解决呢？"><a href="#如何解决呢？" class="headerlink" title="如何解决呢？"></a>如何解决呢？</h3><ul><li>META标签</li></ul><p>在网站的<code>&lt;head&gt;</code>标签内添加一行声明<code>referrer</code>的规则</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>referrer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>same-origin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>referrer<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no-referrer<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是这种方法也不是万无一失的。防盗链本质是检测Http请求中的请求方地址，这样相当于是把Http请求中自己的地址给删除了，可以骗过新浪的防盗链。这样以来就会影响到一些需要这个特性的功能，比如网站统计访问的功能就可能不能正常工作了。</p><ul><li>IMG标签</li></ul><p>既然是图片资源，那么在<code>HTML5</code>中的<code>img</code>标签有一个<code>referrerpolicy</code>的属性，可以显示声明<code>referrer</code>规则，所以在图片标签中加入一个属性即可。</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;wx4.sinaimg.cn&#x2F;large&#x2F;006WvzUFly4g2fbc9ojcbj30j60auq3j.jpg&quot; referrerpolicy&#x3D;&quot;no-referrer&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样倒是不会影响其他功能，不过缺点是有点麻烦，要对IMG标签添加属性。</p><ul><li>自建服务器</li></ul><p>既然免费的服务器不给用那就自建一个，专门用来存图或者（土豪方法）。</p><h3 id="选择其他免费的图床来存"><a href="#选择其他免费的图床来存" class="headerlink" title="选择其他免费的图床来存"></a>选择其他免费的图床来存</h3><ul><li>imgur</li></ul><p>著名的老牌国外图床，2009 年就开始运行了。图片存储稳定可靠。</p><ul><li>速度：国外真的挺快，不过国内半墙</li><li>CDN：FastlyCDN（这家 CDN 的很多节点都被墙了）</li><li>HTTPS：支持（不支持 HTTP2）</li><li>域名： <code>i.imgur.com</code></li></ul><p>追求国内访问速度的还是别用了吧，不过这家图床是真的足够稳定可靠。开放有 API（还有支持免费匿名上传图片的 ClientKey 可以申请），也有很多第三方插件可以用。</p><ul><li>SM.MS</li></ul><p>@showfarm 建的图床，2015 年开始正式运营。</p><ul><li>速度：现在估计是被滥用了没那么快了 购买了更多节点、修改了服务架构，现在全球速度还是不错的。</li><li>CDN：烧风自建的 CDN，有中国香港阿里云、DigitalOcean 欧洲和 Linode 北美等节点</li><li>HTTPS：HTTP 会被 301 跳转 HTTPS（支持 HTTP2）</li><li>域名： <code>ooo.0o0.ooo``i.loli.net</code></li></ul><p>支持 API 操作，图片存储非常可靠，V2EX 钦点的图床。iOS 和 Android 应用已经分别上架 <a href="https://link.zhihu.com/?target=https://itunes.apple.com/app/sm-ms/id1268411917">iTunes</a> 和 <a href="https://link.zhihu.com/?target=https://play.google.com/store/apps/details?id=sm.ms">Play Store</a>，甚至有第三方做的 Telegram Bot。在众多公共图床中最看好它和 imgur。</p><ul><li><p>路过图床</p></li><li><p>支持免注册上传图片，永久存储，支持HTTPS加密访问和调用图片，提供多种图片链接格式</p></li><li><p>限制：最大10M</p></li><li><p><a href="https://link.zhihu.com/?target=https://imgchr.com/">上传地址</a></p></li></ul><ul><li><p>极简图床</p></li><li><p>主要提供图片上传和管理界面，需要用户自己设置微博、七牛云或者阿里云OSS信息</p></li><li><p>目前站点维护，原因不详</p></li><li><p><a href="https://link.zhihu.com/?target=http://jiantuku.com/">上传地址</a></p></li></ul><p>还有很多其他的图床就不一一列举。</p><h2 id="图床不行就用自己的"><a href="#图床不行就用自己的" class="headerlink" title="图床不行就用自己的"></a>图床不行就用自己的</h2><h3 id="Github作图床"><a href="#Github作图床" class="headerlink" title="Github作图床"></a>Github作图床</h3><p>用github作图床也是最常用的自己图床的方法，上传博文的时候，连同要用的图片一同上传到github上，在Markdown中用相对路径的写法来引入一同上传到github的图片。</p><ul><li>具体操作方法如下</li><li>HEXO官方给出的方法，这里就直接引用官方网站文档中的内容。</li></ul><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><h2 id="文章资源文件夹"><a href="#文章资源文件夹" class="headerlink" title="文章资源文件夹"></a>文章资源文件夹</h2><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><pre class="line-numbers language-none"><code class="language-none">_config.ymlpost_asset_folder: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><h2 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h2><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><pre class="line-numbers language-none"><code class="language-none">&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><pre class="line-numbers language-none"><code class="language-none">&#123;% asset_img example.jpg This is an example image %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h2 id="Embedding-an-image-using-markdown"><a href="#Embedding-an-image-using-markdown" class="headerlink" title="Embedding an image using markdown"></a>Embedding an image using markdown</h2><p><a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0 introduced a new option that allows you to embed an image in markdown without using <code>asset_img</code> tag plugin.</p><p>To enable:</p><pre class="line-numbers language-none"><code class="language-none">_config.ymlpost_asset_folder: truemarked:  prependRoot: true  postAsset: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Once enabled, an asset image will be automatically resolved to its corresponding post’s path. For example, “image.jpg” is located at “/2020/01/02/foo/image.jpg”, meaning it is an asset image of “/2020/01/02/foo/“ post, <code>![](image.jpg)</code> will be rendered as <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>.</p><p><strong>官方提供的方法确实是可以解决这个问题，但是官方的方法没有使用Markdown的官方语法，而是使用大括号的，感觉在Markdown中突然出现这个很不优雅并且不能在书写的过程中预览图片。所以大家对于这个方法酌情使用。</strong></p><h3 id="安装插件-这个方法参照其他博客提供，会在末尾附上链接。"><a href="#安装插件-这个方法参照其他博客提供，会在末尾附上链接。" class="headerlink" title="安装插件 这个方法参照其他博客提供，会在末尾附上链接。"></a>安装插件 这个方法参照其他博客提供，会在末尾附上链接。</h3><p><strong>设置站点配置<code>_config.yml</code></strong>:</p><p>将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code></p><p>这点和HEXO官方的方法还是一样的，修改配置文件，这样就可以在hexo  n ‘YOUR BLOG’的时候在_post文件夹中生成一个和博文同名的文件夹，专门用来存储这个博文的图片。</p><p>npm安装插件</p><pre class="line-numbers language-none"><code class="language-none">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image -- save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是这个插件的内容需要修改【不然可能会出Bug】</p><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token keyword">var</span> cheerio <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cheerio'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><span class="token keyword">function</span> <span class="token function">getPosition</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> m<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> version <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>hexo<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>filter<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'after_post_render'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> config <span class="token operator">=</span> hexo<span class="token punctuation">.</span>config<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>post_asset_folder<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> link <span class="token operator">=</span> data<span class="token punctuation">.</span>permalink<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>version<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">Number</span><span class="token punctuation">(</span>version<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token keyword">var</span> beginPos <span class="token operator">=</span> <span class="token function">getPosition</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span>   <span class="token keyword">var</span> beginPos <span class="token operator">=</span> <span class="token function">getPosition</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span><span class="token keyword">var</span> endPos <span class="token operator">=</span> link<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    link <span class="token operator">=</span> link<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>beginPos<span class="token punctuation">,</span> endPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> toprocess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'excerpt'</span><span class="token punctuation">,</span> <span class="token string">'more'</span><span class="token punctuation">,</span> <span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> toprocess<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">var</span> key <span class="token operator">=</span> toprocess<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">var</span> $ <span class="token operator">=</span> cheerio<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>        ignoreWhitespace<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        xmlMode<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        lowerCaseTags<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        decodeEntities<span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// For windows style path, we replace '\' to '/'.</span><span class="token keyword">var</span> src <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'\\'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">http[s]*.*|\/\/.*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>   <span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\s*\/</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// For "about" page, the first part of "src" can't be removed.</span>  <span class="token comment">// In addition, to support multi-level local directory.</span>  <span class="token keyword">var</span> linkArray <span class="token operator">=</span> link<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">elem</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> elem <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> srcArray <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">elem</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> elem <span class="token operator">!=</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> elem <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>srcArray<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>srcArray<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  src <span class="token operator">=</span> srcArray<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>root <span class="token operator">+</span> link <span class="token operator">+</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span>info<span class="token operator">&amp;&amp;</span>console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"update link as:-->"</span><span class="token operator">+</span>config<span class="token punctuation">.</span>root <span class="token operator">+</span> link <span class="token operator">+</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span>info<span class="token operator">&amp;&amp;</span>console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"no src attr, skipped..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span>info<span class="token operator">&amp;&amp;</span>console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后在Markdown的文件中引入方式也有一些不同。具体看见下图。</p><p><img src="/2021/03/31/guan-yu-bo-ke-tu-pian-bu-xian-shi-wen-ti-de-jie-jue/p3.png" alt="同目录下游个同名文件夹中存着图片"></p><p><img src="/2021/03/31/guan-yu-bo-ke-tu-pian-bu-xian-shi-wen-ti-de-jie-jue/p2.png" alt="Markdown中的书写方式"></p><p>然后再运行</p><pre class="line-numbers language-none"><code class="language-none">hexo clean hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>即可在本开启服务查看是否图片展示正常，下面给出示例图片。</p><p><img src="/2021/03/31/guan-yu-bo-ke-tu-pian-bu-xian-shi-wen-ti-de-jie-jue/p4.png" alt="如图显示正常"></p><p><strong>但是缺点 – 没有办法在markdown书写过程中预览图片信息，所以不是特别直观，还是需要注意图片不要引用错误。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客图片不显示 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树和随机森林是个啥呢？</title>
      <link href="2021/03/28/guan-yu-jue-ce-shu-yu-sui-ji-sen-lin-de-qian-xian-ren-shi/"/>
      <url>2021/03/28/guan-yu-jue-ce-shu-yu-sui-ji-sen-lin-de-qian-xian-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="关于决策树与随机森林的浅显认识"><a href="#关于决策树与随机森林的浅显认识" class="headerlink" title="关于决策树与随机森林的浅显认识"></a>关于决策树与随机森林的浅显认识</h1><h2 id="决策树是啥？"><a href="#决策树是啥？" class="headerlink" title="决策树是啥？"></a>决策树是啥？</h2><ul><li>百度百科上对于决策树的一些解释</li></ul><p>决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。</p><p>决策树(Decision Tree）是在已知各种情况发生概率的<a href="https://baike.baidu.com/item/%E5%9F%BA%E7%A1%80/32794">基础</a>上，通过构成决策树来求取净现值的<a href="https://baike.baidu.com/item/%E6%9C%9F%E6%9C%9B/35704">期望</a>值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。在机器学习中，决策树是一个预测模型，他代表的是对象属性与对象值之间的一种映射关系。Entropy = 系统的凌乱程度，使用算法<a href="https://baike.baidu.com/item/ID3">ID3</a>, <a href="https://baike.baidu.com/item/C4.5">C4.5</a>和C5.0生成树算法使用熵。</p><ul><li>接下来是我自己通过查阅相关资料和书籍后对于决策树的一些了解</li></ul><p>首先我了解决策树的来源是西瓜书，书上对于决策树用于分类做出了一定的阐述。过于专业的术语就不罗列了，我用通俗的语言把自己的浅显理解表示出来，决策树是通过树形结构，在树的节点上根据数据的某些特来将根节点上输入的数据进行逐次的分类，最终到达叶子节点的时候就能够对根节点上输入的数据进行做出分类。可能说起来表述不是特别直观，我们可以通过书上的例子来理解。</p><p><img src="/2021/03/28/guan-yu-jue-ce-shu-yu-sui-ji-sen-lin-de-qian-xian-ren-shi/p1.jpg" alt="对西瓜是否是好瓜的分类"></p><p>可以从图上看出每个节点的分叉不一定就是两个，可以根据该特征的表现而分出多个叉。</p><ul><li>决策树是如何生产的呢？</li></ul><p>之前图上的决策树可以很直观的看出来一个西瓜从输入到决策树之后是如何的一步一步的按照西瓜自身的特征被分成好瓜和坏瓜。这也决策树和其他机器学习方法（比如深度学习）所更具有优势的地方，那就是决策树的可解释性很强，每一步是怎么来的都可以清晰明了的知道，而不像深度网络的训练那样是个黑盒模型，深度网络本身就不可解释，再加上深度网络的层数加深的时候，这个黑盒也就黑上加黑了。</p><p>那么像图上的那个决策树是怎么知道用哪些西瓜的特征呢？ 那些特征又是如何排序的呢？ 特征所占权重又是如何的呢？ </p><p>上面所有的问题其实都是由决策树的一些算法（如ID3,C4.5）来自己决定的，只要给够数据集，这些都就不用考虑。但是我们学习肯定要抱着求知的心态。所以我也就对其中的一种算法ID3算法做一个简单的介绍。</p><ul><li>ID3</li></ul><p>首先我们要了解一个这个算法涉及的一个知识，那就是信息熵。我对于熵的理解十分浅显，仅限于知道它描述一个系统的混乱程度，一个系统越混乱，那么他的熵就越大，而所有的系统从一开始随着时间的推进，系统的熵是会越来越大的，也就是系统会逐渐的进入到混乱的状态。</p><p>对于熵我还是引用一些dalao的说法：{</p><p>基本思想<strong>是以信息熵</strong>为度量构造一棵熵值下降最快的树，到叶子节点处的熵值为零，此时每个叶节点中的实例都属于同一类。</p><p>ID3算法的核心思想就是以信息增益度量属性选择，选择分裂后信息增益最大（我理解为信息熵-不确定性减小最快）的属性进行分裂。</p><p><em>什么是信息增益？</em></p><p>信息增益表示得知特征A的信息而使得类X的信息的不确定性减少的程度。</p><p>设D为用类别对训练元组进行的划分，则D的<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Entropy">熵</a>（entropy）表示为：</p><p>其中pi表示第i个类别在整个训练元组中出现的概率，可以用属于此类别元素的数量除以训练元组元素总数量作为估计。</p><p>}</p><p>结合之前的图来理解：</p><p>而对于一棵决策树来说呢，从一开始训练一棵树的时候，会把所有的数据集都丢在根节点，此时根节点中的所有数据都是未分类的，那么可以说这个时候根节点的熵是最大的（因为完全未分类，全混乱的自然是熵最大的），但是在训练的过程中，每个节点都代表了一个特征，经过一个节点的分类之后，在下一层中的每个节点中的数据都是经过上一个节点分类下来的，所以说每个节点中的熵都是相较于上一次更小的，那么这一层的所有节点的熵加在一起的和自然也就小于上一层中所有节点的熵之和，这就是ID3算法的思想了，<strong>每一次的熵之和都递减</strong>。依照这个中心思想来训练一棵树，就会按照数据本身的特性来生成树。</p><ul><li><p>那么决策树如何评价决策树这种分类方式呢？</p></li><li><p>优势：</p></li></ul><p>1、便于理解和解释。树的结构可视化<br>2、训练需要的数据少，其他机器学习模型通常需要数据规范化，比如构建虚拟变量和移除缺失值<br>3、由于训练决策树的数据点的数量导致了决策树的使用开销呈指数分布（训练树模型的时间复杂度是参加训练数据点的对数值）<br>4、能够处理数值型数据和分类数据，其他的技术通常只能用来专门分析某一种的变量类型的数据集；<br>5、能够处理多路输出问题；<br>6、使用白盒模型。如果某种给定的情况在模型中是可以观察的，那么就可以轻易的通过布尔逻辑来解释这种情况，相比之下在黑盒模型中的结果就是很难说明清楚了；<br>7、可以通过数值统计测试来验证该模型。这对解释验证该模型的可靠性成为可能；<br>8、即使是该模型假设的结果越真实模型所提供的数据有些违反，其表现依旧良好；</p><ul><li>缺点总而言之就是——容易过拟合</li></ul><p>1、决策树模型容易产生一个过于复杂的模型，这样的模型对数据的泛化性能会很差。这就是所谓的过拟合，一些策略像剪枝、设置叶节点所需要的最小样本数或者设置数的最大深度就是避免出现该问题的最有效的方法。（剪枝：在机器学习经典算法中，决策树算法的重要性想必大家都是知道的。不管是ID3算法还是比如C4.5算法等等，都面临一个问题，就是通过直接生成的完全决策树对于训练样本来说是“过度拟合”的，说白了是太精确了。由于完全决策树对训练样本的特征描述得“过于精确” ,无法实现对新样本的合理分析, 所以此时它不是一棵分析新数据的最佳决策树。解决这个问题的方法就是对决策树进行剪枝，剪去影响预测精度的分支。常见的剪枝策略有预剪枝(pre -pruning)技术和后剪枝(post -pruning )技术两种。预剪枝技术主要是通过建立某些规则限制决策树的充分生长, 后剪枝技术则是待决策树充分生长完毕后再进行剪枝。）<br>2、决策树可能是不稳定的，因为在数据中的微小变化可能会导致完全不同的树生成。这个问题可以通过决策树的集成来得到缓解；<br>3、在多方面性能最优和简单化概念的要求下，学习一颗最优决策树通常是一个NP难问题；<br>因此，实际的决策树学习算法是基于启发式算法，例如在每个节点进行局部最优决策的贪心算法，这样的算法不能保证返回全局最有决策树，这个问题可以通过集成学习来训练多颗决策树来缓解，这多棵决策树一般通过对特征和样本又放回的随机采样来生成；<br>4、有些概念很难被决策树学习到，因为决策树很难清楚的表述那些概念，例如XOR，奇偶或者复用器问题；<br>5、如果某些类在问题中占主导地位会使得创始的决策树有偏差，因此建议在拟合前先对数据集进行平衡。</p><h2 id="随机森林呢？"><a href="#随机森林呢？" class="headerlink" title="随机森林呢？"></a>随机森林呢？</h2><ul><li>之前说了决策树的各种好处，但是他就是不好在容易过拟合。</li></ul><p>那么如何解决过拟合的问题呢？难道因为容易过拟合我们就要放弃这个好的分类器了吗？ 答案自然是不，既然有问题那我们就去解决，然后就出现了更加神奇的随机森林。</p><p>听名字就可以看出来，一个树是决策树，那么有很多随机的树的时候，那就是随机森林了，说起来十分的简单，其实还是有很多不一样的地方。</p><p>森林有了，那么森林中的树是如何生产的呢？还是随机森林。</p><p>生成规则如下：</p><ul><li>如果训练集大小为N，对于每棵树而言，随机且有放回地从训练集中的抽取N个训练样本（这种采样方式称为bootstrap sample方法)，作为该树的训练集; 从这里我们就可以知道，每棵树训练集都是不同的，而且里面包含重复的训练样本（十分重要）。</li><li>那么为什么要随机抽样训练集呢？</li></ul><p>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的，重复的决策树那么该过拟合还是会过拟合。</p><ul><li>那么为什么要有放回地抽样呢?</li></ul><p>我理解的是这样的:如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是”有偏的””，都是绝对”片面的”(当然这样说可能不对)，也就是说每棵树训练出来都是有很大的差异的;而随机森林最后分类取决于多棵树(弱分类器)的投票表决，这种表决应该是”求同””，因此使用完全不同的训练集来训练每棵树这样对最终分类结果是没有帮助的，这样无异于是盲人摸象”。</p><ul><li><p>如果每个样本的特征维度为M，指定一个常数m&lt;&lt;M，随机地从M个特征中选取m个特征子集，每次树进行分裂时，从这m个特征中选择最优的;</p></li><li><p>每棵树都尽最大程度的生长，并且没有剪枝过程。<br>一开始我们提到的随机森林中的”随机”就是指的这里的两个随机性。两个随机性的引入对随机森林的分类性能至关重要。由于它们的引入，使得随机森林不容易陷入过拟合，并且具有很好得抗噪能力(比如:对缺省值不敏感)。</p></li></ul><ul><li><p>随机森林的分类效果和什么因素有关呢？</p><p>1，森林中任意两棵树的相关性:相关性越大，错误率越大;</p><p>2，森林中每棵树的分类能力:每棵树的分类能力越强，整个森林的错误率越低。</p><p><img src="/2021/03/28/guan-yu-jue-ce-shu-yu-sui-ji-sen-lin-de-qian-xian-ren-shi/p2.jpg" alt="这就是一个由三个决策树构成的小森林"></p></li></ul><p>————————————————————————————</p><ul><li>我能够用我自己最通俗的语言来描述随机森林：</li></ul><p>随机森林就像是民主选举，森林就是一个国家，每个决策树都是一个公民，因为每个人的所见所闻都不一样（指训练时候是随机抽样训练的），那么每个公民都对选举（输入的数据或者图片）都有着自己个人的见解（不同数据训练出来的决策树结构都不同，对特征的敏感性也不同），最后每个公民都会对选举做出自己的选择，最后再统计所有公民的选择作为最后的决定。</p><p>正式因为每棵树都与众不同，并且是由不同的很多树共同来做出结果，所以过拟合的问题就这样迎刃而解了。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 随机森林和决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人脸识别入门内容简介</title>
      <link href="2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/"/>
      <url>2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="（个人向）人脸识别，图像处理内容入门学习。"><a href="#（个人向）人脸识别，图像处理内容入门学习。" class="headerlink" title="（个人向）人脸识别，图像处理内容入门学习。"></a>（个人向）人脸识别，图像处理内容入门学习。</h1><h2 id="背景及意义"><a href="#背景及意义" class="headerlink" title="背景及意义"></a>背景及意义</h2><p>人脸识别，是基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，利用人脸固有的特征信息进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。是模式识别和人工智能最广泛的应用之一，通常也叫做人像识别、面部识别。</p><h2 id="人脸识别过程简述"><a href="#人脸识别过程简述" class="headerlink" title="人脸识别过程简述"></a>人脸识别过程简述</h2><p><img src="/2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/p1.png" alt="人脸识别流程图"></p><ol><li>人脸图像采集及检测</li></ol><p>人脸图像采集,不同的人脸图像都能通过图像采集设备采集下来，比如静态的图像、动态图像、不同的位置、不同表情等方面都可以得到很好的采集。人脸检测，在实际中主要用于人脸识别的预处理，即就是在图像中准确标出人脸的位置和大小，人脸图像中包含的模式特征十分丰富，如直方图特征、颜色特征、模板特征、结构特征等。人脸检测就是把这其中有用的信息挑出来，并利用这些特征实现人脸检测。</p><ol start="2"><li>人脸图像预处理</li></ol><p>这是以人脸检测结果为基础的，对图像进行处理并最终服务于特征提取的过程。系统获取的原始图像由于受到各种条件的限制和随机干扰，往往不能直接使用，必须在图像处理的早期阶段对它进行灰度校正、噪声过滤等图像预处理。对于人脸图像而言，其预处理过程主要包括人脸图像的光线补偿、灰度变换、直方图均衡化、归一化、几何校正、滤波以及锐化等。</p><ol start="3"><li>人脸图像特征提取</li></ol><p>人脸图像特征提取：人脸识别系统可使用的特征通常分为视觉特征、像素统计特征、人脸图像变换系数特征、人脸图像代数特征等。人脸特征提取就是针对人脸的某些特征进行的。人脸特征提取，也称人脸表征，它是对人脸进行特征建模的过程。人脸特征提取的方法归纳起来分为两大类：一种是基于知识的表征方法；另外一种是基于代数特征或统计学习的表征方法。</p><ol start="4"><li>人脸图像匹配与识别</li></ol><p>人脸图像匹配与识别：提取的人脸图像的特征数据与数据库中存储的特征模板进行搜索匹配，通过设定一个阈值，当相似度超过这一阈值，则把匹配得到的结果输出。人脸识别就是将待识别的人脸特征与已得到的人脸特征模板进行比较，根据相似程度对人脸的身份信息进行判断。这一过程又分为两类：一类是确认，是一对一进行图像比较的过程，另一类是辨认，是一对多进行图像匹配对比的过程。</p><h2 id="各个部分的简单介绍"><a href="#各个部分的简单介绍" class="headerlink" title="各个部分的简单介绍"></a>各个部分的简单介绍</h2><p><strong>每个部分只单单做简单介绍，可能只会提及少数常用的方法。</strong></p><h3 id="人脸图像的预处理"><a href="#人脸图像的预处理" class="headerlink" title="人脸图像的预处理"></a>人脸图像的预处理</h3><p>人脸识别的图像一般都是通过摄像机、照相机等摄录设备进行采集的，但由于采集的过程中的周围光照环境，强度的不同，所采用的照相设备性能有所不同不同，而导致所采集到的图像存在噪声，而且摄像角度和摄像距离的不同还会导致所得图像中人脸的大小，位置和角度不统一。为了保证识别系统中的对人脸图像的识别具有相同的质量，预处理就成为了人脸识别系统中必不可少的一个步骤。下面介绍几种经常用到的图像预处理方法。</p><p><strong>灰度变换</strong></p><p>灰度变换指的是根据需要的目标条件按一定变换关系逐点改变源图像中每一个像素的灰度值的一种方法。目的是为了改善画质，使图像的显示效果更加清晰。图像的灰度变换处理是图像增强处理技术中的一种非常基础、直接的空间域图像处理方法，也是图像数字化软件和图像显示软件的一个重要组成部分。</p><p>在人脸识别系统中我们所采集到的图像一般是彩色图像，但由于彩色图像中包含较大的数据量和信息量，所以直接对彩色图像进行处理不仅复杂而且耗时。而灰色图像虽然包含数据量较小，但包含的有用信息量却很大，更适合于人脸识别系统的应用。也因此，把彩色图像灰度化是人脸图像预处理的第一步。常用的灰度变换方法有线性变换，分段线性变换和非线性变换方法。</p><p>灰度化常用的经验公式: (其中R G B分别代表彩色图像RGB对应的值，grey则为对应的灰度值)</p><hr><p><strong>gray=0.39×R＋0.5×G＋0.11×B</strong></p><hr><p><img src="/2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/p2.png" alt="灰度处理流程"></p><p><strong>下面是灰度变换的方法(r为输入灰度值，s为输出灰度值)</strong></p><ol><li><p>​    线性变换-较多的是图像反转，图像反转得到的是图像的负片，能够有效的增强在图像暗区域的白色或者灰色细节。</p><hr><p><strong>S = 255-r</strong></p><hr></li></ol><ol start="2"><li><p>对数变换和反对数变换（其中c是一个常数）将源图像中<strong>范</strong>围较窄的低灰度值映射到范围较宽的灰度区间，同时将范围较宽的高灰度值区间映射为较窄的灰度区间，从而扩展了暗像素的值，压缩了高灰度的值，能够对图像中低灰度细节进行增强。</p><hr><p><strong>S = clog(1+r)</strong></p><hr></li></ol><p><img src="/2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/p3.png" alt="对数和反对数函数对应图像"></p><ol start="3"><li><p>幂律变换（其中c和γ为正常数[当γ&lt;1γ&lt;1时，γ的值越小，对图像低灰度值的扩展越明显；当γ&gt;1γ&gt;1时，γ的值越大，对图像高灰度值部分的扩展越明显。这样就能够显示更多的图像的低灰度或者高灰度细节。</p><hr><p><strong>S = （cr）γ次方</strong></p><hr></li></ol><p><img src="/2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/p4.png" alt="幂律变换对应图像"></p><p><strong>几何矫正（具体内容略，只做简述）</strong></p><p>几何校正是用来解决角度问题，主要包括：</p><ul><li>图像的大小矫正。</li><li>图像的平移。</li><li>图像的翻转。</li><li>图像的旋转。</li></ul><p>常用的方法有两种：</p><ul><li>直接几何校正。</li><li>间接法几何校正。</li></ul><p><strong>图像滤波，对图像噪点进行处理</strong></p><p>由于人脸图像的采集环境往往是不理想的，比如存在光照强度的变换、采集设备性能的差异等等都会使采集到的图像中存在噪声，从而影响到采集到的图像质量。为了提升图像的质量水平，减少噪声对后期处理的不良影响，我们需要将图像中的噪声去除。目前常用的图像去噪方法可以分为两类：一类为对图像的全局处理，该类滤波需要事先对信号及噪声的统计模型有所了解，如Wiener滤波、卡尔曼滤波等；另一类为采用局部算子进行的滤波，如中值滤波、均值滤波等。</p><ol><li>  均值滤波。</li></ol><p>作为最简单的线性滤波器之一，其先对图像中目标像素进行局部平均,再把原来的像素值替换成局部平均值。邻域的大小对滤波效果也有很大的影响，邻域窗口的尺寸越大，滤波效果也会更好，但同时也会造成大量图像细节信息的损失，即图像将会变得模糊。</p><p><img src="/2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/p5.png" alt="均值滤波公式"></p><ol start="2"><li>中值滤波</li></ol><p>中值滤波也是一种常见的非线性滤波技术。该方法主要思想是把每一个像素点的灰度值设置为该像素点邻域内的所有像素点灰度值的中值，由于该方法不依赖于邻域中与典型值差别很大的值，所以在去除椒盐噪声和脉冲噪声的同时该方法还能够很好的保留人脸图像的边缘细节信息。</p><p>在图像中去3*3的矩阵，里面有9个像素点，我们将9个像素进行排序，最后将这个矩阵的中心点赋值为这九个像素的中值。如图所示。</p><p><img src="/2020/12/09/ren-lian-shi-bie-ru-men-nei-rong-jian-jie/p6.png" alt="中值滤波"></p><p><strong>图像特征提取方法</strong></p><ol><li><p>SIFT（尺度不变特征变换）</p><p>1.1 尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。</p><p>1.2 关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。</p><p>1.3 方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</p><p>1.4 关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。</p></li></ol><p>经过上述的步骤，尺度变化以及旋转等几何变换的影响就都能够被去除，如果还想再去除光照变化对其产生的影响，可以对特征点描述子进行长度归一化处理</p><ol start="2"><li>PCA-SIFT（主成分分析法结合SIFT）</li><li> GLOH（方向梯度直方图）</li></ol><p><strong>本次内容对于特征提取的方法不做讲解，因为特征提取的方法内容比较多，所以之后会对于不同的特征提取方法单独写篇文章进行具体探讨，这次只提出。</strong></p><p><strong>最后的特征匹配和验证</strong></p><p>提取的人脸图像的特征数据与数据库中存储的特征模板进行搜索匹配，通过设定一个阈值，当相似度超过这一阈值，则把匹配得到的结果输出。人脸识别就是将待识别的人脸特征与已得到的人脸特征模板进行比较，根据相似程度对人脸的身份信息进行判断。这一过程又分为两类：一类是确认，是一对一进行图像比较的过程，另一类是辨认，是一对多进行图像匹配对比的过程。</p><p>支持向量机（Support Vector Machine, SVM）是一类按<a href="https://baike.baidu.com/item/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/9820109">监督学习</a>（supervised learning）方式对数据进行<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%85%83%E5%88%86%E7%B1%BB/15635322">二元分类</a>的广义线性分类器（generalized linear classifier），其<a href="https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E8%BE%B9%E7%95%8C/22778546">决策边界</a>是对学习样本求解的最大边距超平面（maximum-margin hyperplane） 。</p><p>SVM使用铰链损失函数（hinge loss）计算经验风险（empirical risk）并在求解系统中加入了正则化项以优化结构风险（structural risk），是一个具有稀疏性和稳健性的分类器  。SVM可以通过<a href="https://baike.baidu.com/item/%E6%A0%B8%E6%96%B9%E6%B3%95/1683712">核方法</a>（kernel method）进行非线性分类，是常见的核学习（kernel learning）方法之一  。</p><p>还有就是最常用的神经网络方法，但是神经网络内容也比较多，后面想要单独对神经网络的不同模型进行单独探讨，本次只提一下。</p><h2 id="由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。-如果内容对您有帮助或者对此感兴趣请继续关注哦！！！"><a href="#由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。-如果内容对您有帮助或者对此感兴趣请继续关注哦！！！" class="headerlink" title="由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。             如果内容对您有帮助或者对此感兴趣请继续关注哦！！！"></a>由于图像处理，人脸识别内容比较多且庞杂，所以本次只当作对于该领域学习的一个开端，只会也会伴随着我自己的学习不断深入之后继续写一些自己思考的内容以供交流和记录。水平有限，内容不一定正确，如有错误请多多指正。             如果内容对您有帮助或者对此感兴趣请继续关注哦！！！</h2>]]></content>
      
      
      <categories>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数质数的别致方法</title>
      <link href="2020/12/06/ji-shu-zhi-shu-de-bie-zhi-fang-fa/"/>
      <url>2020/12/06/ji-shu-zhi-shu-de-bie-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：-Leetcode-204-计数质数（统计所有小于非负整数n的质数数量）"><a href="#题目：-Leetcode-204-计数质数（统计所有小于非负整数n的质数数量）" class="headerlink" title="题目：  Leetcode - 204.计数质数（统计所有小于非负整数n的质数数量）"></a>题目：  Leetcode - 204.计数质数（统计所有小于非负整数n的质数数量）</h1><ul><li>方法一：枚举</li></ul><p>​    枚举判断每个数是不是质数考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x-1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。这个方法进一步优化可以的得到的结果是，如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在[2，sqrt(x)]区间中 ，因此只需要枚举这个区间中的所有数字即可，这样复杂度就从O(n)降低到了O(sqrt(n))。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">isPrime</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">+=</span> <span class="token function">isPrime</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>方法二：埃氏筛</li></ul><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（EratosthenesEratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们设 isPrime[i]表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> isPrime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/12/06/ji-shu-zhi-shu-de-bie-zhi-fang-fa/p1.gif" alt="示意图"></p><p>注意每次找当前素数 x 的倍数时，是从x平方开始的。因为如果 x &gt; 2，那么 2*x 肯定被素数 2 给过滤了，最小未被过滤的肯定是 x平方。</p><ul><li>线性筛  (了解原理即可，有点超纲)</li></ul><p>根据《算术基本定理》：每一个合数都可以以唯一形式被写成质数的乘积。换言之两个或两个以上质数的乘积，只可以组成一个合数n以内，从2起，遇质数放质数数组。遇数，该数与质数数组中每数相乘。</p><p>数为质数：质数 * 质数 = 合数。<br>数为合数：合数可拆为质数 * 质数 … = 质数 * 质数 … * 质数 = 合数。</p><p>只要作为因子的每个质数都不同，那么合数一定不同，不会重复当前数 能被 质数数组中的某质数 整除，当前数一定是包含 该质数 的合数合数拆分时，因子中，会出现 两个相同质数，不能保证合数不同质数数组中后面质数都比 该质数 大。该质数 * &gt;它的质数 = 合数后面一定会遇到。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">countPrimes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> isPrime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        primes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> primes<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       isPrime<span class="token punctuation">[</span>i <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> primes<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线性筛时间复杂度和空间复杂度均为 : O(n)</strong></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo搭建个人网站的流程（算是小教程）</title>
      <link href="2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/"/>
      <url>2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-node-js-Git简单搭建个人Blog的记录"><a href="#使用Hexo-node-js-Git简单搭建个人Blog的记录" class="headerlink" title="使用Hexo + node.js + Git简单搭建个人Blog的记录"></a>使用Hexo + node.js + Git简单搭建个人Blog的记录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人Blog的用意主要是用于记录研究生期间的生活以及学习。</p><h2 id="搭建个人Blog的必备工具"><a href="#搭建个人Blog的必备工具" class="headerlink" title="搭建个人Blog的必备工具"></a>搭建个人Blog的必备工具</h2><ol><li><p>Hexo</p></li><li><p>Node.js</p></li><li><p>Git</p></li><li><p>代码编辑器  - 用于修改config的必要工具</p></li><li><p>一定的代码阅读能力（雾</p></li></ol><h2 id="第一步-Git的安装和基本使用"><a href="#第一步-Git的安装和基本使用" class="headerlink" title="第一步 Git的安装和基本使用"></a>第一步 Git的安装和基本使用</h2><p>我实在window平台上进行搭建和部署的，故直接再<a href="https://git-scm.com/downloads">Git官网</a>下载对应平台版本即可<img src="/2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/p1.jpg" alt="官网下载"></p><p>下载后的exe可以说说是傻瓜包，直接next-next即可。</p><p>最后在开始菜单栏会出现表示安装成功，但是如果第一次安装的话必须要配置用户信息。<img src="/2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/p2.jpg" alt="开始菜单显示"></p><p>要在git bash中配置用户的用户名和邮箱地址，具体操作如下</p><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token command">$ git config<span class="token parameter"> --global</span> user.name </span><span class="token string">"你的用户名"</span><span class="token command">$ git config<span class="token parameter"> --global</span> user.email </span><span class="token string">"你的邮箱地址"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果用了 <strong>–global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><p>全部操作完成之后算是Git部分完成了。</p><p><strong>恭喜你完成了第一步！！！（congratulation！！！）</strong></p><h2 id="第二部分-Node-js的安装和配置"><a href="#第二部分-Node-js的安装和配置" class="headerlink" title="第二部分 Node.js的安装和配置"></a>第二部分 Node.js的安装和配置</h2><p>照例第一步node.js官方中文网站下载安装<a href="https://nodejs.org/zh-cn/">node.js官网</a>(建议安装长期支持的稳定版本)</p><p><img src="/2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/p3.jpg" alt="node.js官网"></p><p>安装过程省略基本全程next-next（如果安装出现特定的问题建议百度哦）</p><p>Node.js继承了npm工具，全部安装结束之后为了验证安装是否成，进入到cmd(win+r)中输入如图中的指令，如出现如图中的node和npm版本号则说明安装成功。</p><p><img src="/2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/p4.jpg" alt="显示版本号"></p><p>到这里则说明node和npm安装成功！ congratulation！ </p><h2 id="第三部分-基于node-js安装Hexo"><a href="#第三部分-基于node-js安装Hexo" class="headerlink" title="第三部分 基于node.js安装Hexo"></a>第三部分 基于node.js安装Hexo</h2><p>因为我是win平台，所以可以省略的cmd指令就用win有好的GUI操作来代替。</p><p>首先创建一个保存所有的工程文件的文件夹，在win平台操作则非常简单，直接选择一个盘符中创建一个文件夹。再打开CMD（接下来就是cmd指令居多），通过cd指令切换到创建好的文件夹路径中。通过Cmd或者git bash 输入下面的指令来安装 。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成之后再用指令来查看版本即可知道安装成功与否。</p><pre class="line-numbers language-none"><code class="language-none">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现了安装过程异常缓慢或者直接卡主不动的情况下其实是正常的，我们可以用npm安装淘宝的cnpm管理器，用淘宝的源会快一些。指令如下。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装成功之后，继续在这个路径下初始hexo生成和初始化博客，指令如下。</p><pre class="line-numbers language-none"><code class="language-none">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待整个init的过程完成之后在生成的文件夹之中会生成许多的配置文件，我们之后再继续讲解配置网站内容的部分。</p><p>接下来执行以下的操作来在本机上启动blog服务。</p><pre class="line-numbers language-none"><code class="language-none">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在cmd最后会出现用于访问blog的地址为localhost:4000   也就是本机4000端口上。</p><p>打开浏览器输入url即可访问到启动好的blog，不过都是Hexo初始化的主题和内容，还有一篇初始的博客，内容为Hexo的基本操作  就是 hexo g hexo s hexo clean和写新博文hexo new “name”等等的一系列指令。页面如下。</p><p><img src="/2020/12/06/yong-hexo-da-jian-ge-ren-wang-zhan-de-liu-cheng-suan-shi-xiao-jiao-cheng/p5.jpg" alt="默认界面"></p><p><strong>这只是最基本的布局和样式，如果想要让自己的blog更加好看优美需要额外的配置，让页面更好看的操作教程我会再单独的出一篇blog，本次只单独讲最简单启动和部署。</strong></p><h2 id="第四部分-将自己的网站托管到Git上"><a href="#第四部分-将自己的网站托管到Git上" class="headerlink" title="第四部分 将自己的网站托管到Git上"></a>第四部分 将自己的网站托管到Git上</h2><p>之前的操作下来只能在本地启动Hexo的服务，要打开也只能通过本机的localhost 4000端口上。</p><p>托管在第三方上可以让自己的网站Blog随时随地的访问，我们选择把它托管在最受欢迎的Github上，这也是我们首先安装git的原因。</p><p>首先第一步是在web版的github上进入到自己的个人界面新建一个仓库(Respositories)，新建的过程中要把仓库的名称建立得和自己ID一样才可以，具体的格式为       **你的用户ID.github.io   **，穿件完成之后接下来就是要把自己的网站部署到刚刚创建的仓库中。</p><p><strong>不过安装的过程中还要依赖一个额外的插件，依赖这个插件才能完成简单的部署。需要再次使用之前安装的cnpm来完成快速的安装 hexo-deloyer-git</strong> 。  操作的代码如下。</p><pre class="line-numbers language-none"><code class="language-none">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下里等待安装完成即可，倘若是之前切换了淘宝的源安装可能就很快，但是直接用npm可能会很慢或者卡主不动。</p><p>接下来就是配置这个插件。<strong>首先在blog的根目录下打开 _config.yml配置文件找到deployment选项下 修改type为git 再添加repo项，值为你在github上新创建的仓库url,还要选择你上传到的branch</strong>。具体如下。</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy:  type: &#39;git&#39;  repo: https:&#x2F;&#x2F;github.com&quot;你的仓库“  branch : main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里有个小插曲： github在2020年10月分把原本的默认分支master修改为了main（原因呢，是在阿妹你看因为黑人小伙子弗洛伊德之死引发的大规模抗议使得人们看到master容易联想到不好的东西，所以改为了main）</strong>。</p><p>配置完成之后就是部署你的所有文件到github</p><p>使用cmd指令如下即可</p><pre class="line-numbers language-none"><code class="language-none">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后可以在你的github页面对应仓库看到新的提交改动。</p><p>接下来使用**https://“仓库名.github.io/**即可访问到你部署在github上的blog了。</p><p><strong>congratulation！   你已经完成了你的Blog！   在之后我会继续给出如何写新的博文以及修改blog主题和样式让你的blog更加好看，请继续跟进和关注本Blog！！！</strong></p><p><strong>可能会用到的Hexo指令</strong></p><pre class="line-numbers language-none"><code class="language-none">hexo clean   # hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo g       #生成网站静态文件到默认设置的 public 文件夹。hexo s #启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;。hexo d #自动生成网站静态文件，并部署到设定的仓库。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。"><a href="#如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。" class="headerlink" title="如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。"></a>如果您还有兴趣或者这篇帮助到了你，请继续关注哦，接下来会在这篇blog的基础之上继续介绍发布博文的操作和修改主题和样式来让让你的blog更加personalized。</h2>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Blog教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
